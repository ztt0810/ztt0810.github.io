<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据增强</title>
      <link href="2021/03/30/cv/%E2%95%A9%C2%A4%E2%95%9B%E2%96%8C%E2%95%98%D0%8E%E2%95%9F%E2%94%90%E2%95%99%D1%8B%E2%95%A4%E2%95%A1%E2%94%B4%E2%95%96trick/"/>
      <url>2021/03/30/cv/%E2%95%A9%C2%A4%E2%95%9B%E2%96%8C%E2%95%98%D0%8E%E2%95%9F%E2%94%90%E2%95%99%D1%8B%E2%95%A4%E2%95%A1%E2%94%B4%E2%95%96trick/</url>
      
        <content type="html"><![CDATA[<h1 id="yolov5中用到的数据增强和trick总结（上）"><a href="#yolov5中用到的数据增强和trick总结（上）" class="headerlink" title="yolov5中用到的数据增强和trick总结（上）"></a>yolov5中用到的数据增强和trick总结（上）</h1><p>yolov5中用到了许多数据增强方法和trick来提高模型精度，如mosaic, cutout, augment imagespace, augment colorspace，augment hsv, 翻转，旋转等</p><h2 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h2><h3 id="一、Mosaic"><a href="#一、Mosaic" class="headerlink" title="一、Mosaic"></a>一、Mosaic</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Mosaic通过将四张训练图片合并成一张，由此可以提升模型对小目标的检测能力。通常情况下，小目标图片在训练集中的分布并不均匀，这也导致了模型对小样本的学习不够充分，因此在通过mosaic操作后，使得数据集中小目标样本数量得以增加，每张图都有不同程度的缩小，即使没有小目标，通过缩小，原来的目标尺寸也更接近小目标的大小。</p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_mosaic</span>(<span class="params">self, index</span>):</span></span><br><span class="line">    <span class="comment"># loads images in a 4-mosaic</span></span><br><span class="line"><span class="comment"># 将四张图片合并成一张图片</span></span><br><span class="line">    labels4 = []</span><br><span class="line">    s = self.img_size</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在图片中随机选取一个中心点，作为四张图片拼接的中心点, self.mosaic_border = [-img_size // 2, img_size // 2]</span></span><br><span class="line">    yc, xc = [<span class="built_in">int</span>(random.uniform(-x, <span class="number">2</span> * s + x)) <span class="keyword">for</span> x <span class="keyword">in</span> self.mosaic_border]  <span class="comment"># mosaic center x, y</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#随机挑选三张被镶嵌图片，通过indices来索引</span></span><br><span class="line">    indices = [index] + [self. [random.randint(<span class="number">0</span>, self.n - <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]  <span class="comment"># 3 additional image indices</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i, index <span class="keyword">in</span> <span class="built_in">enumerate</span>(indices):</span><br><span class="line">        <span class="comment"># Load image，返回图片矩阵，图片宽和高</span></span><br><span class="line">        img, _, (h, w) = load_image(self, index)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># place img in img4 将4张图片合成为一张，分别放在图像的四个位置</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:  <span class="comment"># top left</span></span><br><span class="line">            img4 = np.full((s * <span class="number">2</span>, s * <span class="number">2</span>, img.shape[<span class="number">2</span>]), <span class="number">114</span>, dtype=np.uint8)  <span class="comment"># base image with 4 tiles</span></span><br><span class="line">            x1a, y1a, x2a, y2a = <span class="built_in">max</span>(xc - w, <span class="number">0</span>), <span class="built_in">max</span>(yc - h, <span class="number">0</span>), xc, yc  <span class="comment"># xmin, ymin, xmax, ymax (large image)</span></span><br><span class="line">            x1b, y1b, x2b, y2b = w - (x2a - x1a), h - (y2a - y1a), w, h  <span class="comment"># xmin, ymin, xmax, ymax (small image)</span></span><br><span class="line">        <span class="keyword">elif</span> i == <span class="number">1</span>:  <span class="comment"># top right</span></span><br><span class="line">            x1a, y1a, x2a, y2a = xc, <span class="built_in">max</span>(yc - h, <span class="number">0</span>), <span class="built_in">min</span>(xc + w, s * <span class="number">2</span>), yc</span><br><span class="line">            x1b, y1b, x2b, y2b = <span class="number">0</span>, h - (y2a - y1a), <span class="built_in">min</span>(w, x2a - x1a), h</span><br><span class="line">        <span class="keyword">elif</span> i == <span class="number">2</span>:  <span class="comment"># bottom left</span></span><br><span class="line">            x1a, y1a, x2a, y2a = <span class="built_in">max</span>(xc - w, <span class="number">0</span>), yc, xc, <span class="built_in">min</span>(s * <span class="number">2</span>, yc + h)</span><br><span class="line">            x1b, y1b, x2b, y2b = w - (x2a - x1a), <span class="number">0</span>, w, <span class="built_in">min</span>(y2a - y1a, h)</span><br><span class="line">        <span class="keyword">elif</span> i == <span class="number">3</span>:  <span class="comment"># bottom right</span></span><br><span class="line">            x1a, y1a, x2a, y2a = xc, yc, <span class="built_in">min</span>(xc + w, s * <span class="number">2</span>), <span class="built_in">min</span>(s * <span class="number">2</span>, yc + h)</span><br><span class="line">            x1b, y1b, x2b, y2b = <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">min</span>(w, x2a - x1a), <span class="built_in">min</span>(y2a - y1a, h)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#把要合并图片放到大的图片里</span></span><br><span class="line">        img4[y1a:y2a, x1a:x2a] = img[y1b:y2b, x1b:x2b]  <span class="comment"># img4[ymin:ymax, xmin:xmax]</span></span><br><span class="line">        padw = x1a - x1b</span><br><span class="line">        padh = y1a - y1b</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Labels</span></span><br><span class="line">        labels = self.labels[index].copy()</span><br><span class="line">        <span class="keyword">if</span> labels.size:</span><br><span class="line">            <span class="comment"># 将label从x, y, w, h转换成x1, y1, x2, y2</span></span><br><span class="line">            labels[:, <span class="number">1</span>:] = xywhn2xyxy(labels[:, <span class="number">1</span>:], w, h, padw, padh)  <span class="comment"># normalized xywh to pixel xyxy format</span></span><br><span class="line">        labels4.append(labels)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Concat/clip labels</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(labels4):</span><br><span class="line">        <span class="comment"># 把四张图片的label进行合并</span></span><br><span class="line">        labels4 = np.concatenate(labels4, <span class="number">0</span>)</span><br><span class="line">        np.clip(labels4[:, <span class="number">1</span>:], <span class="number">0</span>, <span class="number">2</span> * s, out=labels4[:, <span class="number">1</span>:])  <span class="comment"># use with random_perspective</span></span><br><span class="line">        <span class="comment"># img4, labels4 = replicate(img4, labels4)  # replicate</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Augment  对图片做仿射变换或透视变换，由self.hyp[&#x27;perspective&#x27;]决定</span></span><br><span class="line">    img4, labels4 = random_perspective(img4, labels4,</span><br><span class="line">                                       degrees=self.hyp[<span class="string">&#x27;degrees&#x27;</span>],</span><br><span class="line">                                       translate=self.hyp[<span class="string">&#x27;translate&#x27;</span>],</span><br><span class="line">                                       scale=self.hyp[<span class="string">&#x27;scale&#x27;</span>],</span><br><span class="line">                                       shear=self.hyp[<span class="string">&#x27;shear&#x27;</span>],</span><br><span class="line">                                       perspective=self.hyp[<span class="string">&#x27;perspective&#x27;</span>],</span><br><span class="line">                                       border=self.mosaic_border)  <span class="comment"># border to remove</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> img4, labels4</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二、letterbox"><a href="#二、letterbox" class="headerlink" title="二、letterbox"></a>二、letterbox</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>在通常情况下，模型的输入尺寸都是一个固定值，如yolov5为（640，640），但是我们都知道，训练集图片的大小都是不同的，因此需要对图片的尺寸进行统一，此时，我们马上会想到一个方法，cv2.resize()，但是这个方法有一个很大的问题，它会破坏图片的纵横比（aspect ratio），如果图片的长和宽不与目标尺寸成相同比例，那么图片就会失真，结果就是我们的模型精度会收到影响。而letterbox就是在保持纵横比的前提下对图像做resize，先resize然后按需要在周围pad上0像素。说白了就是先按照比例resize到一个与目标尺寸相近的大小，然后通过pad将图片填充到目标尺寸。</p><h4 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">letterbox</span>(<span class="params">img, new_shape=(<span class="params"><span class="number">640</span>, <span class="number">640</span></span>), color=(<span class="params"><span class="number">114</span>, <span class="number">114</span>, <span class="number">114</span></span>), auto=<span class="literal">True</span>, scaleFill=<span class="literal">False</span>, scaleup=<span class="literal">True</span>, stride=<span class="number">32</span></span>):</span></span><br><span class="line">    <span class="comment"># Resize and pad image while meeting stride-multiple constraints</span></span><br><span class="line">    shape = img.shape[:<span class="number">2</span>]  <span class="comment"># current shape [height, width]</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(new_shape, <span class="built_in">int</span>):</span><br><span class="line">        new_shape = (new_shape, new_shape)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Scale ratio (new / old)</span></span><br><span class="line">    <span class="comment"># 计算需要resize的比例，取原始图片大小与目标尺寸长宽比值里较小的一个</span></span><br><span class="line">    r = <span class="built_in">min</span>(new_shape[<span class="number">0</span>] / shape[<span class="number">0</span>], new_shape[<span class="number">1</span>] / shape[<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 如果在测试的时候原始图片尺寸小于目标尺寸，则进行等比例变换，这是为了得到更高的map</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> scaleup:  <span class="comment"># only scale down, do not scale up (for better test mAP)</span></span><br><span class="line">        r = <span class="built_in">min</span>(r, <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Compute padding</span></span><br><span class="line">    ratio = r, r  <span class="comment"># width, height ratios</span></span><br><span class="line">    <span class="comment"># 计算新图片按比例resize的大小</span></span><br><span class="line">    new_unpad = <span class="built_in">int</span>(<span class="built_in">round</span>(shape[<span class="number">1</span>] * r)), <span class="built_in">int</span>(<span class="built_in">round</span>(shape[<span class="number">0</span>] * r))</span><br><span class="line">    <span class="comment"># 计算长和宽分别有多少像素需要填充</span></span><br><span class="line">    dw, dh = new_shape[<span class="number">1</span>] - new_unpad[<span class="number">0</span>], new_shape[<span class="number">0</span>] - new_unpad[<span class="number">1</span>]  <span class="comment"># wh padding</span></span><br><span class="line">    <span class="keyword">if</span> auto:  <span class="comment"># minimum rectangle</span></span><br><span class="line">        dw, dh = np.mod(dw, stride), np.mod(dh, stride)  <span class="comment"># wh padding</span></span><br><span class="line">    <span class="keyword">elif</span> scaleFill:  <span class="comment"># stretch</span></span><br><span class="line">        dw, dh = <span class="number">0.0</span>, <span class="number">0.0</span></span><br><span class="line">        new_unpad = (new_shape[<span class="number">1</span>], new_shape[<span class="number">0</span>])</span><br><span class="line">       <span class="comment"># 计算原始图片尺寸与目标尺寸的纵横比</span></span><br><span class="line">        ratio = new_shape[<span class="number">1</span>] / shape[<span class="number">1</span>], new_shape[<span class="number">0</span>] / shape[<span class="number">0</span>]  <span class="comment"># width, height ratios</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将长和宽分别分成两个部分，长分成左右填充到图片中，宽分成上和下填充到图片中</span></span><br><span class="line">    dw /= <span class="number">2</span>  <span class="comment"># divide padding into 2 sides</span></span><br><span class="line">    dh /= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> shape[::-<span class="number">1</span>] != new_unpad:  <span class="comment"># resize</span></span><br><span class="line">        img = cv2.resize(img, new_unpad, interpolation=cv2.INTER_LINEAR)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 对填充大小四舍五入取整</span></span><br><span class="line">    top, bottom = <span class="built_in">int</span>(<span class="built_in">round</span>(dh - <span class="number">0.1</span>)), <span class="built_in">int</span>(<span class="built_in">round</span>(dh + <span class="number">0.1</span>))</span><br><span class="line">    left, right = <span class="built_in">int</span>(<span class="built_in">round</span>(dw - <span class="number">0.1</span>)), <span class="built_in">int</span>(<span class="built_in">round</span>(dw + <span class="number">0.1</span>))</span><br><span class="line">    <span class="comment"># 填充像素</span></span><br><span class="line">    img = cv2.copyMakeBorder(img, top, bottom, left, right, cv2.BORDER_CONSTANT, value=color)  <span class="comment"># add border</span></span><br><span class="line">    <span class="keyword">return</span> img, ratio, (dw, dh)</span><br></pre></td></tr></table></figure><h3 id="三、augment-hsv"><a href="#三、augment-hsv" class="headerlink" title="三、augment_hsv"></a>三、augment_hsv</h3><p>对hsv色彩空间进行增强</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">r = np.random.uniform(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>) * [hgain, sgain, vgain] + <span class="number">1</span>  <span class="comment"># random gains</span></span><br><span class="line">   hue, sat, val = cv2.split(cv2.cvtColor(img, cv2.COLOR_BGR2HSV))</span><br><span class="line">   dtype = img.dtype  <span class="comment"># uint8</span></span><br><span class="line"></span><br><span class="line">   x = np.arange(<span class="number">0</span>, <span class="number">256</span>, dtype=np.int16)</span><br><span class="line">   lut_hue = ((x * r[<span class="number">0</span>]) % <span class="number">180</span>).astype(dtype)</span><br><span class="line">   lut_sat = np.clip(x * r[<span class="number">1</span>], <span class="number">0</span>, <span class="number">255</span>).astype(dtype)</span><br><span class="line">   lut_val = np.clip(x * r[<span class="number">2</span>], <span class="number">0</span>, <span class="number">255</span>).astype(dtype)</span><br><span class="line"></span><br><span class="line">   img_hsv = cv2.merge((cv2.LUT(hue, lut_hue), cv2.LUT(sat, lut_sat), cv2.LUT(val, lut_val))).astype(dtype)</span><br><span class="line">   cv2.cvtColor(img_hsv, cv2.COLOR_HSV2BGR, dst=img)  <span class="comment"># no return needed</span></span><br></pre></td></tr></table></figure><h3 id="四、cutout"><a href="#四、cutout" class="headerlink" title="四、cutout"></a>四、cutout</h3><p>对样本的随机区域进行擦除，并填充0像素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cutout</span>(<span class="params">image, labels</span>):</span></span><br><span class="line">    <span class="comment"># Applies image cutout augmentation https://arxiv.org/abs/1708.04552</span></span><br><span class="line">    h, w = image.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bbox_ioa</span>(<span class="params">box1, box2</span>):</span></span><br><span class="line">        <span class="comment"># Returns the intersection over box2 area given box1, box2. box1 is 4, box2 is nx4. boxes are x1y1x2y2</span></span><br><span class="line">        box2 = box2.transpose()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Get the coordinates of bounding boxes</span></span><br><span class="line">        b1_x1, b1_y1, b1_x2, b1_y2 = box1[<span class="number">0</span>], box1[<span class="number">1</span>], box1[<span class="number">2</span>], box1[<span class="number">3</span>]</span><br><span class="line">        b2_x1, b2_y1, b2_x2, b2_y2 = box2[<span class="number">0</span>], box2[<span class="number">1</span>], box2[<span class="number">2</span>], box2[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Intersection area</span></span><br><span class="line">        inter_area = (np.minimum(b1_x2, b2_x2) - np.maximum(b1_x1, b2_x1)).clip(<span class="number">0</span>) * \</span><br><span class="line">                     (np.minimum(b1_y2, b2_y2) - np.maximum(b1_y1, b2_y1)).clip(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># box2 area</span></span><br><span class="line">        box2_area = (b2_x2 - b2_x1) * (b2_y2 - b2_y1) + <span class="number">1e-16</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Intersection over box2 area</span></span><br><span class="line">        <span class="keyword">return</span> inter_area / box2_area</span><br><span class="line"></span><br><span class="line">    <span class="comment"># create random masks</span></span><br><span class="line">    scales = [<span class="number">0.5</span>] * <span class="number">1</span> + [<span class="number">0.25</span>] * <span class="number">2</span> + [<span class="number">0.125</span>] * <span class="number">4</span> + [<span class="number">0.0625</span>] * <span class="number">8</span> + [<span class="number">0.03125</span>] * <span class="number">16</span>  <span class="comment"># image size fraction</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> scales:</span><br><span class="line">        mask_h = random.randint(<span class="number">1</span>, <span class="built_in">int</span>(h * s))</span><br><span class="line">        mask_w = random.randint(<span class="number">1</span>, <span class="built_in">int</span>(w * s))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># box</span></span><br><span class="line">        xmin = <span class="built_in">max</span>(<span class="number">0</span>, random.randint(<span class="number">0</span>, w) - mask_w // <span class="number">2</span>)</span><br><span class="line">        ymin = <span class="built_in">max</span>(<span class="number">0</span>, random.randint(<span class="number">0</span>, h) - mask_h // <span class="number">2</span>)</span><br><span class="line">        xmax = <span class="built_in">min</span>(w, xmin + mask_w)</span><br><span class="line">        ymax = <span class="built_in">min</span>(h, ymin + mask_h)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># apply random color mask</span></span><br><span class="line">        image[ymin:ymax, xmin:xmax] = [random.randint(<span class="number">64</span>, <span class="number">191</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># return unobscured labels</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(labels) <span class="keyword">and</span> s &gt; <span class="number">0.03</span>:</span><br><span class="line">            box = np.array([xmin, ymin, xmax, ymax], dtype=np.float32)</span><br><span class="line">            ioa = bbox_ioa(box, labels[:, <span class="number">1</span>:<span class="number">5</span>])  <span class="comment"># intersection over area</span></span><br><span class="line">            labels = labels[ioa &lt; <span class="number">0.60</span>]  <span class="comment"># remove &gt;60% obscured labels</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> labels</span><br></pre></td></tr></table></figure><h3 id="五、随机水平翻转和垂直翻转"><a href="#五、随机水平翻转和垂直翻转" class="headerlink" title="五、随机水平翻转和垂直翻转"></a>五、随机水平翻转和垂直翻转</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> self.augment:</span><br><span class="line">    <span class="comment"># flip up-down</span></span><br><span class="line">    <span class="keyword">if</span> random.random() &lt; hyp[<span class="string">&#x27;flipud&#x27;</span>]:</span><br><span class="line">        img = np.flipud(img)</span><br><span class="line">        <span class="keyword">if</span> nL:</span><br><span class="line">            labels[:, <span class="number">2</span>] = <span class="number">1</span> - labels[:, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># flip left-right</span></span><br><span class="line">    <span class="keyword">if</span> random.random() &lt; hyp[<span class="string">&#x27;fliplr&#x27;</span>]:</span><br><span class="line">        img = np.fliplr(img)</span><br><span class="line">        <span class="keyword">if</span> nL:</span><br><span class="line">            labels[:, <span class="number">1</span>] = <span class="number">1</span> - labels[:, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">labels_out = torch.zeros((nL, <span class="number">6</span>))     </span><br></pre></td></tr></table></figure><h3 id="六、随机仿射变换"><a href="#六、随机仿射变换" class="headerlink" title="六、随机仿射变换"></a>六、随机仿射变换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_perspective</span>(<span class="params">img, targets=(<span class="params"></span>), degrees=<span class="number">10</span>, translate=<span class="number">.1</span>, scale=<span class="number">.1</span>, shear=<span class="number">10</span>, perspective=<span class="number">0.0</span>, border=(<span class="params"><span class="number">0</span>, <span class="number">0</span></span>)</span>):</span></span><br><span class="line">    <span class="comment"># torchvision.transforms.RandomAffine(degrees=(-10, 10), translate=(.1, .1), scale=(.9, 1.1), shear=(-10, 10))</span></span><br><span class="line">    <span class="comment"># targets = [cls, xyxy]</span></span><br><span class="line"></span><br><span class="line">    height = img.shape[<span class="number">0</span>] + border[<span class="number">0</span>] * <span class="number">2</span>  <span class="comment"># shape(h,w,c)</span></span><br><span class="line">    width = img.shape[<span class="number">1</span>] + border[<span class="number">1</span>] * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Center</span></span><br><span class="line">    C = np.eye(<span class="number">3</span>)</span><br><span class="line">    C[<span class="number">0</span>, <span class="number">2</span>] = -img.shape[<span class="number">1</span>] / <span class="number">2</span>  <span class="comment"># x translation (pixels)</span></span><br><span class="line">    C[<span class="number">1</span>, <span class="number">2</span>] = -img.shape[<span class="number">0</span>] / <span class="number">2</span>  <span class="comment"># y translation (pixels)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Perspective</span></span><br><span class="line">    P = np.eye(<span class="number">3</span>)</span><br><span class="line">    P[<span class="number">2</span>, <span class="number">0</span>] = random.uniform(-perspective, perspective)  <span class="comment"># x perspective (about y)</span></span><br><span class="line">    P[<span class="number">2</span>, <span class="number">1</span>] = random.uniform(-perspective, perspective)  <span class="comment"># y perspective (about x)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Rotation and Scale</span></span><br><span class="line">    R = np.eye(<span class="number">3</span>)</span><br><span class="line">    a = random.uniform(-degrees, degrees)</span><br><span class="line">    <span class="comment"># a += random.choice([-180, -90, 0, 90])  # add 90deg rotations to small rotations</span></span><br><span class="line">    s = random.uniform(<span class="number">1</span> - scale, <span class="number">1</span> + scale)</span><br><span class="line">    <span class="comment"># s = 2 ** random.uniform(-scale, scale)</span></span><br><span class="line">    R[:<span class="number">2</span>] = cv2.getRotationMatrix2D(angle=a, center=(<span class="number">0</span>, <span class="number">0</span>), scale=s)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Shear</span></span><br><span class="line">    S = np.eye(<span class="number">3</span>)</span><br><span class="line">    S[<span class="number">0</span>, <span class="number">1</span>] = math.tan(random.uniform(-shear, shear) * math.pi / <span class="number">180</span>)  <span class="comment"># x shear (deg)</span></span><br><span class="line">    S[<span class="number">1</span>, <span class="number">0</span>] = math.tan(random.uniform(-shear, shear) * math.pi / <span class="number">180</span>)  <span class="comment"># y shear (deg)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Translation</span></span><br><span class="line">    T = np.eye(<span class="number">3</span>)</span><br><span class="line">    T[<span class="number">0</span>, <span class="number">2</span>] = random.uniform(<span class="number">0.5</span> - translate, <span class="number">0.5</span> + translate) * width  <span class="comment"># x translation (pixels)</span></span><br><span class="line">    T[<span class="number">1</span>, <span class="number">2</span>] = random.uniform(<span class="number">0.5</span> - translate, <span class="number">0.5</span> + translate) * height  <span class="comment"># y translation (pixels)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Combined rotation matrix</span></span><br><span class="line">    M = T @ S @ R @ P @ C  <span class="comment"># order of operations (right to left) is IMPORTANT</span></span><br><span class="line">    <span class="keyword">if</span> (border[<span class="number">0</span>] != <span class="number">0</span>) <span class="keyword">or</span> (border[<span class="number">1</span>] != <span class="number">0</span>) <span class="keyword">or</span> (M != np.eye(<span class="number">3</span>)).<span class="built_in">any</span>():  <span class="comment"># image changed</span></span><br><span class="line">        <span class="keyword">if</span> perspective:</span><br><span class="line">            img = cv2.warpPerspective(img, M, dsize=(width, height), borderValue=(<span class="number">114</span>, <span class="number">114</span>, <span class="number">114</span>))</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># affine</span></span><br><span class="line">            img = cv2.warpAffine(img, M[:<span class="number">2</span>], dsize=(width, height), borderValue=(<span class="number">114</span>, <span class="number">114</span>, <span class="number">114</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Visualize</span></span><br><span class="line">    <span class="comment"># import matplotlib.pyplot as plt</span></span><br><span class="line">    <span class="comment"># ax = plt.subplots(1, 2, figsize=(12, 6))[1].ravel()</span></span><br><span class="line">    <span class="comment"># ax[0].imshow(img[:, :, ::-1])  # base</span></span><br><span class="line">    <span class="comment"># ax[1].imshow(img2[:, :, ::-1])  # warped</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Transform labels coordinates</span></span><br><span class="line">    n = <span class="built_in">len</span>(targets)</span><br><span class="line">    <span class="keyword">if</span> n:</span><br><span class="line">        <span class="comment"># warp points</span></span><br><span class="line">        xy = np.ones((n * <span class="number">4</span>, <span class="number">3</span>))</span><br><span class="line">        xy[:, :<span class="number">2</span>] = targets[:, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]].reshape(n * <span class="number">4</span>, <span class="number">2</span>)  <span class="comment"># x1y1, x2y2, x1y2, x2y1</span></span><br><span class="line">        xy = xy @ M.T  <span class="comment"># transform</span></span><br><span class="line">        <span class="keyword">if</span> perspective:</span><br><span class="line">            xy = (xy[:, :<span class="number">2</span>] / xy[:, <span class="number">2</span>:<span class="number">3</span>]).reshape(n, <span class="number">8</span>)  <span class="comment"># rescale</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># affine</span></span><br><span class="line">            xy = xy[:, :<span class="number">2</span>].reshape(n, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># create new boxes</span></span><br><span class="line">        x = xy[:, [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]]</span><br><span class="line">        y = xy[:, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]]</span><br><span class="line">        xy = np.concatenate((x.<span class="built_in">min</span>(<span class="number">1</span>), y.<span class="built_in">min</span>(<span class="number">1</span>), x.<span class="built_in">max</span>(<span class="number">1</span>), y.<span class="built_in">max</span>(<span class="number">1</span>))).reshape(<span class="number">4</span>, n).T</span><br><span class="line"></span><br><span class="line">        <span class="comment"># # apply angle-based reduction of bounding boxes</span></span><br><span class="line">        <span class="comment"># radians = a * math.pi / 180</span></span><br><span class="line">        <span class="comment"># reduction = max(abs(math.sin(radians)), abs(math.cos(radians))) ** 0.5</span></span><br><span class="line">        <span class="comment"># x = (xy[:, 2] + xy[:, 0]) / 2</span></span><br><span class="line">        <span class="comment"># y = (xy[:, 3] + xy[:, 1]) / 2</span></span><br><span class="line">        <span class="comment"># w = (xy[:, 2] - xy[:, 0]) * reduction</span></span><br><span class="line">        <span class="comment"># h = (xy[:, 3] - xy[:, 1]) * reduction</span></span><br><span class="line">        <span class="comment"># xy = np.concatenate((x - w / 2, y - h / 2, x + w / 2, y + h / 2)).reshape(4, n).T</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># clip boxes</span></span><br><span class="line">        xy[:, [<span class="number">0</span>, <span class="number">2</span>]] = xy[:, [<span class="number">0</span>, <span class="number">2</span>]].clip(<span class="number">0</span>, width)</span><br><span class="line">        xy[:, [<span class="number">1</span>, <span class="number">3</span>]] = xy[:, [<span class="number">1</span>, <span class="number">3</span>]].clip(<span class="number">0</span>, height)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># filter candidates</span></span><br><span class="line">        i = box_candidates(box1=targets[:, <span class="number">1</span>:<span class="number">5</span>].T * s, box2=xy.T)</span><br><span class="line">        targets = targets[i]</span><br><span class="line">        targets[:, <span class="number">1</span>:<span class="number">5</span>] = xy[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> img, targets</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://zhuanlan.zhihu.com/p/93822508">https://zhuanlan.zhihu.com/p/93822508</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Vision </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
            <tag> Computer Vision </tag>
            
            <tag> Data Augmentation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么要选择shufflenet，而不是mobilenet</title>
      <link href="2021/02/19/cv/why_shufflenet/"/>
      <url>2021/02/19/cv/why_shufflenet/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要选择shufflenet，而不是mobilenet"><a href="#为什么要选择shufflenet，而不是mobilenet" class="headerlink" title="为什么要选择shufflenet，而不是mobilenet"></a>为什么要选择shufflenet，而不是mobilenet</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在了解shufflenet和mobilenet之前我们需要先了解一下各种神奇的卷积骚操作</p><h3 id="1-1-1卷积-（Pointwise-Group-Convolutions）"><a href="#1-1-1卷积-（Pointwise-Group-Convolutions）" class="headerlink" title="1. 1*1卷积 （Pointwise Group Convolutions）"></a>1. 1*1卷积 （Pointwise Group Convolutions）</h3><p>我们都知道卷积核的一个特性就是，输出图像的纬度只取决于卷积核的数量！其实内部原理拿1x1卷积核来举个栗子就是，1x1卷积核相当于一个全连接层，对channel这一维度的信息进行全连接操作，所以能够实现升维或是降维。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol><li>降维/升维</li><li>增加非线性</li><li>跨通道信息交互（channal 的变换）</li></ol><p>例子：使用1x1卷积核，实现降维和升维的操作其实就是channel间信息的线性组合变化，3x3，64channels的卷积核后面添加一个1x1，28channels的卷积核，就变成了3x3，28channels的卷积核，原来的64个channels就可以理解为跨通道线性组合变成了28channels，这就是通道间的信息交互</p><h3 id="2-深度可分卷积（Depthwise-Separable-Convolution）"><a href="#2-深度可分卷积（Depthwise-Separable-Convolution）" class="headerlink" title="2. 深度可分卷积（Depthwise Separable Convolution）"></a>2. 深度可分卷积（Depthwise Separable Convolution）</h3><p>深度可分卷积包含两个步骤：深度卷积和 1×1 卷积。</p><p>假设输入层大小是7 * 7 * 3 ，而过滤器大小为3 * 3 * 3， 那么我们可以得到一个5 * 5 * 1的特征图，而一般来说，在两层网络间回使用多个过滤器，假设我们这里使用128个过滤器，在应用了这128个5 * 5  * 1个过滤器后，我们会得到128个5 * 5 * 1特征图，经过堆叠操作，我们就可以得到一个5 * 5 * 128的特征图。这么一通操作下来，我们从一个7 * 7 *3的特征图，得到了一个5 * 5 *128的特征图，由此我们可以得到计算量为3 * 3 * 3 * 128 = 3456</p><p><img src="/2021/02/19/cv/why_shufflenet/20200405142938967.png" alt="20200405142938967"></p><p>下面我们使用深度可分卷积</p><p>还是7 * 7 * 3的输入 ，这次我们不再使用一个3 * 3 * 3的过滤器，而是使用三个 3 * 3 * 1的过滤器，并将他们堆叠起来，得到5 * 5 * 3 的特征图。接下来，为了扩展深度，们应用一个核大小为 1×1×3 的 1×1 卷积。将 5×5×3 的输入图像与每个 1×1×3 的核卷积，可得到大小为 5×5×1 的映射图。因此，在应用了 128 个 1×1 卷积之后，我们得到大小为 5×5×128 的特征图。计算量为3 * 3 * 1 * 128 = 1152</p><p><img src="/2021/02/19/cv/why_shufflenet/20200405143457446.png" alt="20200405143457446"></p><h2 id="ShuffleNet"><a href="#ShuffleNet" class="headerlink" title="ShuffleNet"></a>ShuffleNet</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ShuffleNet的核心设计理念是对不同的channels进行shuffle来解决group convolution带来的弊端。Group convolution是将输入层的不同特征图进行分组，然后采用不同的卷积核再对各个组进行卷积，这样会降低卷积的计算量。因为一般的卷积都是在所有的输入特征图上做卷积，可以说是全通道卷积，这是一种通道密集连接方式（channel dense connection）。而group convolution相比则是一种通道稀疏连接方式（channel sparse connection）。虽然这样降低了计算量，但同时也带来了一个问题，group convolution中不同组之间的特征图是不通信的，就好比分了三条不相干的路，各走各的，这样会降低网络的特征提取能力，因此为了保证组之间的相互通信，在mobilenet中密集的使用了1 * 1的卷积。</p><h3 id="channel-shuffle"><a href="#channel-shuffle" class="headerlink" title="channel shuffle"></a>channel shuffle</h3><p>而ShuffleNet中提出的channel shuffle则很好的解决了这个问题，通过打乱组内顺序，可以实现对特征图的重组，这样可以保证接下了采用的group convolution其输入来自不同的组，因此信息可以在不同组之间流转。</p><p>让我们来看看channel shuffle是如何工作的。</p><ol><li>将Feature Map 展开成g * n * w * h的四维矩阵，为了简单理解，我们把w * h降到以为，表示s</li><li>沿着尺寸为g * n * s的矩阵的g轴和n轴进行转置</li><li>将g轴和n轴进行平铺后得到洗牌之后的Feature Map；</li><li>进行组内1 * 1的卷积。</li></ol><p><img src="/2021/02/19/cv/why_shufflenet/v2-ea1b29e7ea3609d1001b14faa1ba3547_1440w.jpg" alt="v2-ea1b29e7ea3609d1001b14faa1ba3547_1440w"></p><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>基于上面的设计理念，首先来构造ShuffleNet的基本单元，如图2所示。ShuffleNet的基本单元是在一个残差单元的基础上改进而成的。如图2-a所示，这是一个包含3层的残差单元：首先是1x1卷积，然后是3x3的depthwise convolution（DWConv，主要是为了降低计算量），这里的3x3卷积是瓶颈层（bottleneck），紧接着是1x1卷积，最后是一个短路连接，将输入直接加到输出上。现在，进行如下的改进：将密集的1x1卷积替换成1x1的group convolution，不过在第一个1x1卷积之后增加了一个channel shuffle操作。值得注意的是3x3卷积后面没有增加channel shuffle，按paper的意思，对于这样一个残差单元，一个channel shuffle操作是足够了。还有就是3x3的depthwise convolution之后没有使用ReLU激活函数。改进之后如图2-b所示。对于残差单元，如果stride=1时，此时输入与输出shape一致可以直接相加，而当stride=2时，通道数增加，而特征图大小减小，此时输入与输出不匹配。一般情况下可以采用一个1x1卷积将输入映射成和输出一样的shape。但是在ShuffleNet中，却采用了不一样的策略，如图2-c所示：对原输入采用stride=2的3x3 avg pool，这样得到和输出一样大小的特征图，然后将得到特征图与输出进行连接（concat），而不是相加。这样做的目的主要是降低计算量与参数大小。</p><p><img src="/2021/02/19/cv/why_shufflenet/v2-a8d5297a16f7bcc40a31d427cf062e58_r.jpg" alt="v2-a8d5297a16f7bcc40a31d427cf062e58_r"></p><h2 id="MobileNet"><a href="#MobileNet" class="headerlink" title="MobileNet"></a>MobileNet</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>MobileNet[1]（这里叫做MobileNet v1，简称v1）中使用的Depthwise Separable Convolution是模型压缩的一个最为经典的策略，它是通过将跨通道的 3 * 3卷积换成单通道的 3 * 3卷积+跨通道的1 * 1卷积来达到此目的的。</p><p>MobileNet v2 [2]是在v1的Depthwise Separable的基础上引入了残差结构。并发现了ReLU的在通道数较少的Feature Map上有非常严重信息损失问题，由此引入了Linear Bottlenecks和Inverted Residual。</p><h3 id="MobileNetV1"><a href="#MobileNetV1" class="headerlink" title="MobileNetV1"></a>MobileNetV1</h3><p>mobilenetv1其实可以理解成vgg用deepwise卷积和point wise卷积替换了传统卷积构成的，至于什么是deepwise卷积，上面已经做出了解释。</p><h3 id="MobileNetV2"><a href="#MobileNetV2" class="headerlink" title="MobileNetV2"></a>MobileNetV2</h3><p>相较于v1，v2做出了一些改进，加入了残差结构</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相比较于mobilenet，个人还是更加倾向于使用shufflenet，shufflenet中的channel split和channel shuffle很好的解决了mobilenet中没有解决的特征图之间的通信问题，是网络的特征提取能力得到了提升。同时，由于引入了channel split和channel shuffle，就不再需要过多的pointwise 卷积去实现特征图通道间的通信，在一定程度上也减少了计算量。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://blog.csdn.net/justsolow/article/details/105326447?utm_source=app&amp;app_version=4.9.1&amp;utm_source=app">https://blog.csdn.net/justsolow/article/details/105326447?utm_source=app&amp;app_version=4.9.1&amp;utm_source=app</a></p><p><a href="https://zhuanlan.zhihu.com/p/32304419">https://zhuanlan.zhihu.com/p/32304419</a></p><p><a href="https://zhuanlan.zhihu.com/p/51566209">https://zhuanlan.zhihu.com/p/51566209</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Vision </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Vision </tag>
            
            <tag> Image Classification </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【目标检测系列】Faster-RCNN网络结构解读与代码分析</title>
      <link href="2021/02/14/cv/faster-rcnn/"/>
      <url>2021/02/14/cv/faster-rcnn/</url>
      
        <content type="html"><![CDATA[<h1 id="【目标检测系列】Faster-RCNN网络结构解读与代码分析"><a href="#【目标检测系列】Faster-RCNN网络结构解读与代码分析" class="headerlink" title="【目标检测系列】Faster-RCNN网络结构解读与代码分析"></a>【目标检测系列】Faster-RCNN网络结构解读与代码分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经过R-CNN和Fast RCNN的积淀，由何凯明大神提出的Faster-RCNN，将特征提取（feature extraction），候选框提取（替代了R-CNN与Fast RCNN中比较耗时的<strong>Selective Search</strong>），bbox回归和分类都整合到一个网络中。推理第一阶段先找出图片中待检测物体的anchor矩形框（对背景、待检测物体进行二分类），第二阶段对anchor框内待检测物体进行分类。极大的提升了检测的速度和精度。本文将对<strong>Faster-RCNN</strong>的网络结构进行解读并结合<a href="https://github.com/jwyang/faster-rcnn.pytorch">代码</a>进行分析。</p><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><h3 id="整体结构图："><a href="#整体结构图：" class="headerlink" title="整体结构图："></a>整体结构图：</h3><p><img src="/2021/02/14/cv/faster-rcnn/v2-c0172be282021a1029f7b72b51079ffe_720w.jpg" alt="img"></p><h3 id="特征提取网络（Backbone"><a href="#特征提取网络（Backbone" class="headerlink" title="特征提取网络（Backbone)"></a>特征提取网络（Backbone)</h3><p>​    Backbone又称骨干网络，用于共享卷积基础层，提取特征（feature map），给后面的RPN和全连接层使用，比较常用的Backbone有ResNet系列，EfficientNet系列，如果对精度的要求比较高，可以考虑这两类网络，如果是移动端对速度的要求比较高，可以使用shuffleNet系列，mobileNet系列，还有最近新出的<a href="https://github.com/DingXiaoH/RepVGG">RepVGG</a>也是一个不错的选择。</p><p>​    而本文代码中使用的是vgg16作为backbone，由于篇幅的原因，且不同的backbone的处理方式会有细微的差别，因此本文对于vgg16的细节不进行展开，后续会有专门的章节介绍backbone(挖坑)</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_init_modules</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">import</span> torchvision.models <span class="keyword">as</span> models</span><br><span class="line">    vgg = models.vgg16()</span><br><span class="line">   <span class="keyword">if</span> self.pretrained:</span><br><span class="line">        print(<span class="string">&quot;Loading pretrained weights from %s&quot;</span> %(self.model_path))</span><br><span class="line">        state_dict = torch.load(self.model_path)</span><br><span class="line">        vgg.load_state_dict(&#123;k:v <span class="keyword">for</span> k,v <span class="keyword">in</span> state_dict.items() <span class="keyword">if</span> k <span class="keyword">in</span> vgg.state_dict()&#125;)</span><br><span class="line"></span><br><span class="line">    vgg.classifier = nn.Sequential(*<span class="built_in">list</span>(vgg.classifier._modules.values())[:-<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># not using the last maxpool layer</span></span><br><span class="line">    self.RCNN_base = nn.Sequential(*<span class="built_in">list</span>(vgg.features._modules.values())[:-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>​    上面的代码中，作者使用的是torchvision自带的models，去掉了vgg16的最后一层池化层，也就是去掉了降采样，我想原因应该是想提取更多的小尺度特征吧😄</p><h3 id="区域提议网络（Region-Proposal-Network）"><a href="#区域提议网络（Region-Proposal-Network）" class="headerlink" title="区域提议网络（Region Proposal Network）"></a>区域提议网络（Region Proposal Network）</h3><h4 id="网络结构图："><a href="#网络结构图：" class="headerlink" title="网络结构图："></a>网络结构图：</h4><p><img src="/2021/02/14/cv/faster-rcnn/v2-1908feeaba591d28bee3c4a754cca282_720w.jpg" alt="img"></p><p>​    RPN可以说是Faster-RCNN的灵魂所在，传统的<strong>Selective Search</strong>说白了就是穷举，然后对每个区域进行打分，得到与ground truth最接近的目标，相当耗时。而RPN的精妙之处就在于他凭借anchor生成候选框，接着通过softmax区别正负anchor, 然后对正样本进行<strong>边界框回归（Bounding Box Regression）</strong>以修正anchor得到精准的提议框（proposal）后面用于对提议框进行目标分类。</p><p>（看完一长串概念，脑子里必定是一堆问号，什么是anchor？它长啥样？它是怎么生成的？什么是边界框回归？？？此时心中一万只羊驼路过。我说停停，这就给你解释😁）</p><h4 id="Anchor"><a href="#Anchor" class="headerlink" title="Anchor"></a>Anchor</h4><p>​    其实anchor跟selective search的作用是差不多的，也是为了得到一堆可能包含待检测目标的bounding box。它具体作法是把每个特征点映射回原图的感受野的中心点当成一个基准点，这里面小伙伴们肯定会有疑惑，特征点该怎么映射回原图呢？，首先我们需要明确，特征图是原图经过卷积操作后得到的，而卷积就是卷积核在图片矩阵上进行滑动窗口式遍历操作，原图受卷积核影响的区域被称为感受野，如果我们最后得到的特征图式60*60的，那么在原图上也就对应了60个感受野，我们将感受野的中心作为anchor的基准点，我们假设第一个感受野的中心是（0，0），这就是我们的第一个基准点，接下去的基准点都与前一个基准点相隔base_size个点（base_size指感受野大小），显然最后我们生成了60个基准点，然后围绕这60个基准点选取k个不同scale、aspect ratio的anchor。论文中3个scale（三种面积{128^2，256^2，512^2}），3个aspect ratio( 三种长宽比{1:1，1:2，2:1} )，下图是以一个基准点生成的k（k=9）个anchor，那么剩下的基准点以此类推。</p><p><img src="/2021/02/14/cv/faster-rcnn/v2-9962c78b9963fc323ba04ffb80f0cd95_720w.png" alt="img"></p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enumerate_shifted_anchor</span>(<span class="params">base_anchor, base_size, width, height</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    function description: 减少不必要的如generate_base_anchors的计算, 较大的特征图的锚框生成模板, 生成锚框的初选模板即滑动窗口</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param base_anchor: 需要reshape的anchors</span></span><br><span class="line"><span class="string">    :param base_size: 特征图的每个像素的感受野大小</span></span><br><span class="line"><span class="string">    :param height: featuremap的高度</span></span><br><span class="line"><span class="string">    :param width: featuremap的宽度</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">        anchor: 维度为:[width*height*k, 4]的先验框(anchors)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 计算featuremap中每个像素点在原图中感受野上的中心点坐标</span></span><br><span class="line">    shift_x = np.arange(<span class="number">0</span>, width * base_size, base_size)</span><br><span class="line">    shift_y = np.arange(<span class="number">0</span>, height * base_size, base_size)</span><br><span class="line">    shift_x, shift_y = np.meshgrid(shift_x, shift_y)</span><br><span class="line">    print(<span class="string">&#x27;shift_x: &#x27;</span>, shift_x.shape, <span class="string">&#x27;shift_y: &#x27;</span>, shift_y.shape)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># TODO 感觉最正统的方法还是遍历中心点</span></span><br><span class="line">    <span class="comment"># index = 0</span></span><br><span class="line">    <span class="comment"># for x in shift_x:</span></span><br><span class="line">    <span class="comment">#     for y in shift_y:</span></span><br><span class="line">    <span class="comment">#         anchors = generate_base_anchors(center_x=x, center_y=y)</span></span><br><span class="line">    <span class="comment">#         if index == 0:</span></span><br><span class="line">    <span class="comment">#             old_anchors = anchors</span></span><br><span class="line">    <span class="comment">#         else:</span></span><br><span class="line">    <span class="comment">#             anchors = np.concatenate((old_anchors, anchors), axis=0)</span></span><br><span class="line">    <span class="comment">#             old_anchors = anchors</span></span><br><span class="line">    <span class="comment">#         index += 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># TODO 直接利用broadcast貌似也可以达到目的</span></span><br><span class="line">    <span class="comment"># shift_x.ravel()表示原地将为一维数组, shift的维度为: [feature_stride, 4]</span></span><br><span class="line">    shift = np.stack((shift_x.ravel(), shift_y.ravel(), shift_x.ravel(), shift_y.ravel(),), axis=<span class="number">1</span>)</span><br><span class="line">    A = base_anchor.shape[<span class="number">0</span>]</span><br><span class="line">    K = shift.shape[<span class="number">0</span>]</span><br><span class="line">    anchor = base_anchor.reshape((<span class="number">1</span>, A, <span class="number">4</span>)) + shift.reshape((K, <span class="number">1</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 最后再合成为所有的先验框, 相当于对featuremap的每个像素点都生成k(9)个先验框(anchors)</span></span><br><span class="line">    anchors = anchor.reshape((K * A, <span class="number">4</span>)).astype(np.float32)</span><br><span class="line">    print(<span class="string">&#x27;result: &#x27;</span>, anchors.shape)</span><br><span class="line">    <span class="keyword">return</span> anchors</span><br></pre></td></tr></table></figure><p>上面的代码中，首先我们需要求出感受点中心对应在原图中的坐标</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shift_x = np.arange(<span class="number">0</span>, width * base_size, base_size)</span><br><span class="line">shift_y = np.arange(<span class="number">0</span>, height * base_size, base_size)</span><br><span class="line">shift_x, shift_y = np.meshgrid(shift_x, shift_y)</span><br></pre></td></tr></table></figure><p>接着我们生成anchors</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shift = np.stack((shift_x.ravel(), shift_y.ravel(), shift_x.ravel(), shift_y.ravel(),), axis=<span class="number">1</span>)</span><br><span class="line">A = base_anchor.shape[<span class="number">0</span>]</span><br><span class="line">K = shift.shape[<span class="number">0</span>]</span><br><span class="line">anchor = base_anchor.reshape((<span class="number">1</span>, A, <span class="number">4</span>)) + shift.reshape((K, <span class="number">1</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后再合成为所有的先验框, 相当于对featuremap的每个像素点都生成k(9)个先验框(anchors)</span></span><br><span class="line">anchors = anchor.reshape((K * A, <span class="number">4</span>)).astype(np.float32)</span><br></pre></td></tr></table></figure><p>那么base_anchor（以（0,0）为基准点的第一组anchor）是怎么来的呢</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># Verify that we compute the same anchors as Shaoqing&#x27;s matlab implementation:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    &gt;&gt; load output/rpn_cachedir/faster_rcnn_VOC2007_ZF_stage1_rpn/anchors.mat</span></span><br><span class="line"><span class="comment">#    &gt;&gt; anchors</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    anchors =</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       -83   -39   100    56</span></span><br><span class="line"><span class="comment">#      -175   -87   192   104</span></span><br><span class="line"><span class="comment">#      -359  -183   376   200</span></span><br><span class="line"><span class="comment">#       -55   -55    72    72</span></span><br><span class="line"><span class="comment">#      -119  -119   136   136</span></span><br><span class="line"><span class="comment">#      -247  -247   264   264</span></span><br><span class="line"><span class="comment">#       -35   -79    52    96</span></span><br><span class="line"><span class="comment">#       -79  -167    96   184</span></span><br><span class="line"><span class="comment">#      -167  -343   184   360</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#array([[ -83.,  -39.,  100.,   56.],</span></span><br><span class="line"><span class="comment">#       [-175.,  -87.,  192.,  104.],</span></span><br><span class="line"><span class="comment">#       [-359., -183.,  376.,  200.],</span></span><br><span class="line"><span class="comment">#       [ -55.,  -55.,   72.,   72.],</span></span><br><span class="line"><span class="comment">#       [-119., -119.,  136.,  136.],</span></span><br><span class="line"><span class="comment">#       [-247., -247.,  264.,  264.],</span></span><br><span class="line"><span class="comment">#       [ -35.,  -79.,   52.,   96.],</span></span><br><span class="line"><span class="comment">#       [ -79., -167.,   96.,  184.],</span></span><br><span class="line"><span class="comment">#       [-167., -343.,  184.,  360.]])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    xrange          <span class="comment"># Python 2</span></span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    xrange = <span class="built_in">range</span>  <span class="comment"># Python 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_anchors</span>(<span class="params">base_size=<span class="number">16</span>, ratios=[<span class="number">0.5</span>, <span class="number">1</span>, <span class="number">2</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">                     scales=<span class="number">2</span>**np.arange(<span class="params"><span class="number">3</span>, <span class="number">6</span></span>)</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Generate anchor (reference) windows by enumerating aspect ratios X</span></span><br><span class="line"><span class="string">    scales wrt a reference (0, 0, 15, 15) window.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    base_anchor = np.array([<span class="number">1</span>, <span class="number">1</span>, base_size, base_size]) - <span class="number">1</span></span><br><span class="line">    ratio_anchors = _ratio_enum(base_anchor, ratios)</span><br><span class="line">    print(<span class="string">f&#x27;ratio_anchors : <span class="subst">&#123;ratio_anchors&#125;</span>&#x27;</span>)</span><br><span class="line">    anchors = np.vstack([_scale_enum(ratio_anchors[i, :], scales)</span><br><span class="line">                         <span class="keyword">for</span> i <span class="keyword">in</span> xrange(ratio_anchors.shape[<span class="number">0</span>])])</span><br><span class="line">    <span class="keyword">return</span> anchors</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_whctrs</span>(<span class="params">anchor</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Return width, height, x center, and y center for an anchor (window).</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    w = anchor[<span class="number">2</span>] - anchor[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">    h = anchor[<span class="number">3</span>] - anchor[<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">    x_ctr = anchor[<span class="number">0</span>] + <span class="number">0.5</span> * (w - <span class="number">1</span>)</span><br><span class="line">    y_ctr = anchor[<span class="number">1</span>] + <span class="number">0.5</span> * (h - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> w, h, x_ctr, y_ctr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_mkanchors</span>(<span class="params">ws, hs, x_ctr, y_ctr</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Given a vector of widths (ws) and heights (hs) around a center</span></span><br><span class="line"><span class="string">    (x_ctr, y_ctr), output a set of anchors (windows).</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    ws = ws[:, np.newaxis]</span><br><span class="line">    hs = hs[:, np.newaxis]</span><br><span class="line">    anchors = np.hstack((x_ctr - <span class="number">0.5</span> * (ws - <span class="number">1</span>),</span><br><span class="line">                         y_ctr - <span class="number">0.5</span> * (hs - <span class="number">1</span>),</span><br><span class="line">                         x_ctr + <span class="number">0.5</span> * (ws - <span class="number">1</span>),</span><br><span class="line">                         y_ctr + <span class="number">0.5</span> * (hs - <span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">return</span> anchors</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_ratio_enum</span>(<span class="params">anchor, ratios</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Enumerate a set of anchors for each aspect ratio wrt an anchor.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    w, h, x_ctr, y_ctr = _whctrs(anchor)</span><br><span class="line">    size = w * h</span><br><span class="line">    size_ratios = size / ratios</span><br><span class="line">    print(<span class="string">f&#x27;size_ratios : <span class="subst">&#123;size_ratios&#125;</span>&#x27;</span>)</span><br><span class="line">    ws = np.<span class="built_in">round</span>(np.sqrt(size_ratios))</span><br><span class="line">    hs = np.<span class="built_in">round</span>(ws * ratios)</span><br><span class="line">    print(<span class="string">f&#x27;ws: <span class="subst">&#123;ws&#125;</span>, hs : <span class="subst">&#123;hs&#125;</span>&#x27;</span>)</span><br><span class="line">    anchors = _mkanchors(ws, hs, x_ctr, y_ctr)</span><br><span class="line">    <span class="keyword">return</span> anchors</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_scale_enum</span>(<span class="params">anchor, scales</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Enumerate a set of anchors for each scale wrt an anchor.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    w, h, x_ctr, y_ctr = _whctrs(anchor)</span><br><span class="line">    <span class="comment"># print(f&#x27;w, h, x_ctr, y_ctr in scale enum: &#123;w, h, x_ctr, y_ctr&#125;&#x27;)</span></span><br><span class="line">    print(<span class="string">f&#x27;scales: <span class="subst">&#123;scales&#125;</span>&#x27;</span>)</span><br><span class="line">    ws = w * scales</span><br><span class="line">    hs = h * scales</span><br><span class="line">    <span class="comment"># print(f&#x27;ws, hs : &#123;ws, hs&#125;&#x27;)</span></span><br><span class="line">    anchors = _mkanchors(ws, hs, x_ctr, y_ctr)</span><br><span class="line">    print(<span class="string">f&#x27;scaled anchor: <span class="subst">&#123;anchors&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> anchors</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    t = time.time()</span><br><span class="line">    all_anchors = generate_anchors()</span><br><span class="line">    print(<span class="string">f&#x27;generated anchor: <span class="subst">&#123;all_anchors&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    上面的代码中 generate_anchors 主要负责生成anchor，_whctrs负责将坐标转换为（宽，高，中心点x坐标，中心点y坐标），_mkanchors负责将坐标转换为（左上x，左上y，右下x，右下y）也就是anchor的坐标形式，_ratio_enum是根据设置的ratio，生成位于同一中心点面积相等但坐标不同anchor，也就是图中的同色矩形，而_scale_enum则是生成，同比例，但是面积不同的k组anchor，大小由scale决定，面积为base_size * scale.</p><p>到这里，anchor的生成也就结束了。</p><p>得到了先验框，那我们怎么才能筛选出含有目标物体的框呢</p><p>首先我们需要简单的筛选一下，哪些框包含物体，哪些不包含，一个比较直观的方法就是计算bounding box和groud truth 的交并比，也就是我们经常能看到的一个名词<strong>IOU</strong></p><h4 id="IOU"><a href="#IOU" class="headerlink" title="IOU"></a>IOU</h4><p>IOU的定义是bounding box 与ground truth 的交集，比上他俩的并集，一般我们设定当iou大于0.7则认为bounding box 包含了目标，即为正类，当iou小于0.3时我们则认为他是一个负类，意思是不包含目标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Iou</span>(<span class="params">box1, box2, wh=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> wh == <span class="literal">False</span>:</span><br><span class="line">xmin1, ymin1, xmax1, ymax1 = box1</span><br><span class="line">xmin2, ymin2, xmax2, ymax2 = box2</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">xmin1, ymin1 = <span class="built_in">int</span>(box1[<span class="number">0</span>]-box1[<span class="number">2</span>]/<span class="number">2.0</span>), <span class="built_in">int</span>(box1[<span class="number">1</span>]-box1[<span class="number">3</span>]/<span class="number">2.0</span>)</span><br><span class="line">xmax1, ymax1 = <span class="built_in">int</span>(box1[<span class="number">0</span>]+box1[<span class="number">2</span>]/<span class="number">2.0</span>), <span class="built_in">int</span>(box1[<span class="number">1</span>]+box1[<span class="number">3</span>]/<span class="number">2.0</span>)</span><br><span class="line">xmin2, ymin2 = <span class="built_in">int</span>(box2[<span class="number">0</span>]-box2[<span class="number">2</span>]/<span class="number">2.0</span>), <span class="built_in">int</span>(box2[<span class="number">1</span>]-box2[<span class="number">3</span>]/<span class="number">2.0</span>)</span><br><span class="line">xmax2, ymax2 = <span class="built_in">int</span>(box2[<span class="number">0</span>]+box2[<span class="number">2</span>]/<span class="number">2.0</span>), <span class="built_in">int</span>(box2[<span class="number">1</span>]+box2[<span class="number">3</span>]/<span class="number">2.0</span>)</span><br><span class="line">    <span class="comment"># 获取矩形框交集对应的左上角和右下角的坐标（intersection）</span></span><br><span class="line">    xx1 = np.<span class="built_in">max</span>([xmin1, xmin2])</span><br><span class="line">    yy1 = np.<span class="built_in">max</span>([ymin1, ymin2])</span><br><span class="line">    xx2 = np.<span class="built_in">min</span>([xmax1, xmax2])</span><br><span class="line">    yy2 = np.<span class="built_in">min</span>([ymax1, ymax2])</span><br><span class="line">    <span class="comment"># 计算两个矩形框面积</span></span><br><span class="line">    area1 = (xmax1-xmin1) * (ymax1-ymin1) </span><br><span class="line">    area2 = (xmax2-xmin2) * (ymax2-ymin2)</span><br><span class="line">    inter_area = (np.<span class="built_in">max</span>([<span class="number">0</span>, xx2-xx1])) * (np.<span class="built_in">max</span>([<span class="number">0</span>, yy2-yy1]))　<span class="comment">#计算交集面积</span></span><br><span class="line">    iou = inter_area / (area1+area2-inter_area+<span class="number">1e-6</span>) 　<span class="comment">#计算交并比</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iou</span><br></pre></td></tr></table></figure><h4 id="NMS"><a href="#NMS" class="headerlink" title="NMS"></a>NMS</h4><p>当我们的anchor通过<strong>softmax</strong>分类后，筛选出了positive anchor，这时候就到了RPN的最后一步了，使用<strong>NMS(Non-Maximum Suppression)</strong> 对我们的positive anchor进行最后一步的筛选，首先，我们需要对所有的positive anchor按照分类score进行排序，</p><p>将score最大的那个加入到最终的检测结果集合中，直到positive anchor集合中所有大于阈值的anchor全部加到检测结果集合中，即positive anchor集合为空。</p><p><img src="/2021/02/14/cv/faster-rcnn/606386-20170826153025589-977347485.png" alt="606386-20170826153025589-977347485"></p><p>就像上面的图片一样，定位一个车辆，最后算法就找出了一堆的方框，我们需要判别哪些矩形框是没用的。非极大值抑制的方法是：先假设有6个矩形框，根据分类器的类别分类概率做排序，假设从小到大属于车辆的概率 分别为A、B、C、D、E、F。</p><ol><li><p>从最大概率矩形框F开始，分别判断A~E与F的重叠度IOU是否大于某个设定的阈值;</p></li><li><p>假设B、D与F的重叠度超过阈值，那么就扔掉B、D；并标记第一个矩形框F，是我们保留下来的。</p></li><li><p>从剩下的矩形框A、C、E中，选择概率最大的E，然后判断E与A、C的重叠度，重叠度大于一定的阈值，那么就扔掉；并标记E是我们保留下来的第二个矩形框。</p></li></ol><p>就这样一直重复，找到所有被保留下来的矩形框。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">py_cpu_nms</span>(<span class="params">dets, thresh</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Pure Python NMS baseline.&quot;&quot;&quot;</span></span><br><span class="line">    x1 = dets[:, <span class="number">0</span>]</span><br><span class="line">    y1 = dets[:, <span class="number">1</span>]</span><br><span class="line">    x2 = dets[:, <span class="number">2</span>]</span><br><span class="line">    y2 = dets[:, <span class="number">3</span>]</span><br><span class="line">    scores = dets[:, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">    areas = (x2 - x1 + <span class="number">1</span>) * (y2 - y1 + <span class="number">1</span>)</span><br><span class="line">    order = scores.argsort()[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    keep = []</span><br><span class="line">    <span class="keyword">while</span> order.size &gt; <span class="number">0</span>:</span><br><span class="line">        i = order[<span class="number">0</span>]</span><br><span class="line">        keep.append(i)</span><br><span class="line">        xx1 = np.maximum(x1[i], x1[order[<span class="number">1</span>:]])</span><br><span class="line">        yy1 = np.maximum(y1[i], y1[order[<span class="number">1</span>:]])</span><br><span class="line">        xx2 = np.minimum(x2[i], x2[order[<span class="number">1</span>:]])</span><br><span class="line">        yy2 = np.minimum(y2[i], y2[order[<span class="number">1</span>:]])</span><br><span class="line"></span><br><span class="line">        w = np.maximum(<span class="number">0.0</span>, xx2 - xx1 + <span class="number">1</span>)</span><br><span class="line">        h = np.maximum(<span class="number">0.0</span>, yy2 - yy1 + <span class="number">1</span>)</span><br><span class="line">        inter = w * h</span><br><span class="line">        ovr = inter / (areas[i] + areas[order[<span class="number">1</span>:]] - inter)</span><br><span class="line"></span><br><span class="line">        inds = np.where(ovr &lt;= thresh)[<span class="number">0</span>]</span><br><span class="line">        order = order[inds + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> keep</span><br></pre></td></tr></table></figure><h3 id="ROI-pooling"><a href="#ROI-pooling" class="headerlink" title="ROI-pooling"></a>ROI-pooling</h3><p>ROI-pooling是池化的一种，顾名思义就是对ROI的池化，他的特点是输入图像的尺度不同，输出图像的尺度相同，</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><ol><li>原始的feature map（与RPN部分共享）</li><li>RPN输出的proposal boxes</li></ol><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>将得到的roi映射回原图的feature map，并对feature map进行pooled_w，pooled_h大小等分，然后对等分的每个区域进行max pooling，从而得到固定大小的feature map，这样做的好处是不用受限于roi和feature map大小，实现了固定长度输出，加快处理速度。</p><h3 id="Classification"><a href="#Classification" class="headerlink" title="Classification"></a>Classification</h3><p>当我们得到了ROI-pooling输出的feature map和RPN输出的proposal boxes之后，就可以进行分类了。通过full connect和softmax计算每个proposal属于哪个类别，并输出cls_prob，同时再次利用bounding box regression对预测框进行修正，用于得到更加精准的目标检测框。</p><p><img src="/2021/02/14/cv/faster-rcnn/v2-9377a45dc8393d546b7b52a491414ded_720w.jpg" alt="v2-9377a45dc8393d546b7b52a491414ded_720w"></p><p>由上图可知，分类网络一共做了两件事</p><ol><li>通过全连接和softmax对proposals进行分类</li><li>再次对proposals进行bounding box regression，获取更高精度的rect box</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://zhuanlan.zhihu.com/p/24916624">https://zhuanlan.zhihu.com/p/24916624</a></p><p><a href="https://zhuanlan.zhihu.com/p/82185598">https://zhuanlan.zhihu.com/p/82185598</a></p><p><a href="https://zhuanlan.zhihu.com/p/31426458">https://zhuanlan.zhihu.com/p/31426458</a></p><p><a href="https://zhuanlan.zhihu.com/p/102978748">https://zhuanlan.zhihu.com/p/102978748</a></p><p><a href="https://blog.csdn.net/cj1561435010/article/details/106649040">https://blog.csdn.net/cj1561435010/article/details/106649040</a></p><p><a href="https://zhuanlan.zhihu.com/p/94799295">https://zhuanlan.zhihu.com/p/94799295</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Vision </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Vision </tag>
            
            <tag> Object Detection </tag>
            
            <tag> Two Stage Algorithm </tag>
            
            <tag> anchor based </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盘点那些年我们用过的iou损失函数</title>
      <link href="2021/02/02/cv/loss_in_yolo/"/>
      <url>2021/02/02/cv/loss_in_yolo/</url>
      
        <content type="html"><![CDATA[<h1 id="盘点yolo中用到iou损失函数（GIOU-lOSS，DIOU-Loss-CIOU-Loss"><a href="#盘点yolo中用到iou损失函数（GIOU-lOSS，DIOU-Loss-CIOU-Loss" class="headerlink" title="盘点yolo中用到iou损失函数（GIOU_lOSS，DIOU_Loss,CIOU_Loss,  )"></a>盘点yolo中用到iou损失函数（GIOU_lOSS，DIOU_Loss,CIOU_Loss,  )</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在目标检测中，iou是目标检测中十分常用的一个评价指标，在anchor-based的方法中，他的作用不仅用来确定正样本和负样本，还可以用来评价输出框（predict box）和ground-truth的距离。他有以下两个优点：</p><ol><li>可以说它可以反映预测检测框与真实检测框的检测效果。</li><li>还有一个很好的特性就是<strong>尺度不变性</strong>，也就是对尺度不敏感（scale invariant）， 在regression任务中，判断predict box和gt的距离最直接的指标就是IoU。**(满足非负性；同一性；对称性；三角不等性)**</li></ol><h2 id="IOU-Loss"><a href="#IOU-Loss" class="headerlink" title="IOU_Loss"></a>IOU_Loss</h2><p>因为他可以表示预测框与真实框的距离，用于描述预测框与真实框之间的状态，那么理所当然的可以作为一个损失函数，用于边框回归当中。但是它也有一定的缺点：</p><ol><li>如果两个框没有相交，根据定义，IoU=0，不能反映两者的距离大小（重合度）。同时因为loss=0，没有梯度回传，无法进行学习训练。</li><li>IoU无法精确的反映两者的重合度大小。如下图所示，三种情况IoU都相等，但看得出来他们的重合度是不一样的，左边的图回归的效果最好，右边的最差。</li></ol><p><img src="/2021/02/02/cv/loss_in_yolo/iou_loss.jpg" alt="iou_loss"></p><h2 id="GIOU-Loss"><a href="#GIOU-Loss" class="headerlink" title="GIOU_Loss"></a>GIOU_Loss</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在cvpr2019中 ，<a href="https://arxiv.org/abs/1902.09630">论文</a>提出了GIOU的概念，公式如下</p><p><img src="/2021/02/02/cv/loss_in_yolo/giou_formula.png" alt="giou_formula"></p><p><img src="/2021/02/02/cv/loss_in_yolo/giou.jpg" alt="giou"></p><p>其中C表示预测框与真实框的最小外接矩形 ，GIOU_Loss的创新点在于，加上了一项比值（最小外接矩形面积减去a b交集 比上 最小外接矩形面积），解决了当边框不相交时候iou为零的情况。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Giou</span>(<span class="params">rec1,rec2</span>):</span></span><br><span class="line">    <span class="comment">#分别是第一个矩形左右上下的坐标</span></span><br><span class="line">    x1,x2,y1,y2 = rec1 </span><br><span class="line">    x3,x4,y3,y4 = rec2</span><br><span class="line">    iou = Iou(rec1,rec2)</span><br><span class="line">    area_C = (<span class="built_in">max</span>(x1,x2,x3,x4)-<span class="built_in">min</span>(x1,x2,x3,x4))*(<span class="built_in">max</span>(y1,y2,y3,y4)-<span class="built_in">min</span>(y1,y2,y3,y4))</span><br><span class="line">    area_1 = (x2-x1)*(y1-y2)</span><br><span class="line">    area_2 = (x4-x3)*(y3-y4)</span><br><span class="line">    sum_area = area_1 + area_2</span><br><span class="line"></span><br><span class="line">    w1 = x2 - x1   <span class="comment">#第一个矩形的宽</span></span><br><span class="line">    w2 = x4 - x3   <span class="comment">#第二个矩形的宽</span></span><br><span class="line">    h1 = y1 - y2</span><br><span class="line">    h2 = y3 - y4</span><br><span class="line">    W = <span class="built_in">min</span>(x1,x2,x3,x4)+w1+w2-<span class="built_in">max</span>(x1,x2,x3,x4)    <span class="comment">#交叉部分的宽</span></span><br><span class="line">    H = <span class="built_in">min</span>(y1,y2,y3,y4)+h1+h2-<span class="built_in">max</span>(y1,y2,y3,y4)    <span class="comment">#交叉部分的高</span></span><br><span class="line">    Area = W*H    <span class="comment">#交叉的面积</span></span><br><span class="line">    add_area = sum_area - Area    <span class="comment">#两矩形并集的面积</span></span><br><span class="line"></span><br><span class="line">    end_area = (area_C - add_area)/area_C    <span class="comment">#闭包区域中不属于两个框的区域占闭包区域的比重</span></span><br><span class="line">    giou = iou - end_area</span><br><span class="line">    <span class="keyword">return</span> giou</span><br></pre></td></tr></table></figure><p>但GIOU_Loss仍然存在这问题，当预测框处在真实框的内部时，GIOU的值是相同的，无法区分两个边框的相对位置</p><p><img src="/2021/02/02/cv/loss_in_yolo/giou_shortness.jpg" alt="giou_shortness"></p><h2 id="DIOU-Loss"><a href="#DIOU-Loss" class="headerlink" title="DIOU_Loss"></a>DIOU_Loss</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>为了解决GIOU_Loss产生的问题，DIOU_Loss提出在加上一项距离项，该距离是指预测框中心与真实框中心的欧式距离，因为考虑了重叠面积和中心点距离，当目标框包裹预测框的时候，直接度量2个框的距离，因此DIOU_Loss收敛的更快。</p><p><img src="/2021/02/02/cv/loss_in_yolo/diou_formula.svg" alt="diou_formula"></p><p>其中b，bgt分别表示预测框和真实框的中心，ρ表示b，bpt的欧氏距离（两点间距离），c表示最小外接矩形的对角线长度</p><p><img src="/2021/02/02/cv/loss_in_yolo/DIOU.jpg" alt="DIOU"></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diou</span>(<span class="params">bboxes1, bboxes2</span>):</span></span><br><span class="line">    bboxes1 = torch.sigmoid(bboxes1)</span><br><span class="line">    bboxes2 = torch.sigmoid(bboxes2)</span><br><span class="line">    rows = bboxes1.shape[<span class="number">0</span>]</span><br><span class="line">    cols = bboxes2.shape[<span class="number">0</span>]</span><br><span class="line">    cious = torch.zeros((rows, cols))</span><br><span class="line">    <span class="keyword">if</span> rows * cols == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> cious</span><br><span class="line">    exchange = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> bboxes1.shape[<span class="number">0</span>] &gt; bboxes2.shape[<span class="number">0</span>]:</span><br><span class="line">        bboxes1, bboxes2 = bboxes2, bboxes1</span><br><span class="line">        cious = torch.zeros((cols, rows))</span><br><span class="line">        exchange = <span class="literal">True</span></span><br><span class="line">    w1 = torch.exp(bboxes1[:, <span class="number">2</span>])</span><br><span class="line">    h1 = torch.exp(bboxes1[:, <span class="number">3</span>])</span><br><span class="line">    w2 = torch.exp(bboxes2[:, <span class="number">2</span>])</span><br><span class="line">    h2 = torch.exp(bboxes2[:, <span class="number">3</span>])</span><br><span class="line">    area1 = w1 * h1</span><br><span class="line">    area2 = w2 * h2</span><br><span class="line">    center_x1 = bboxes1[:, <span class="number">0</span>]</span><br><span class="line">    center_y1 = bboxes1[:, <span class="number">1</span>]</span><br><span class="line">    center_x2 = bboxes2[:, <span class="number">0</span>]</span><br><span class="line">    center_y2 = bboxes2[:, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    inter_l = torch.<span class="built_in">max</span>(center_x1 - w1 / <span class="number">2</span>,center_x2 - w2 / <span class="number">2</span>)</span><br><span class="line">    inter_r = torch.<span class="built_in">min</span>(center_x1 + w1 / <span class="number">2</span>,center_x2 + w2 / <span class="number">2</span>)</span><br><span class="line">    inter_t = torch.<span class="built_in">max</span>(center_y1 - h1 / <span class="number">2</span>,center_y2 - h2 / <span class="number">2</span>)</span><br><span class="line">    inter_b = torch.<span class="built_in">min</span>(center_y1 + h1 / <span class="number">2</span>,center_y2 + h2 / <span class="number">2</span>)</span><br><span class="line">    inter_area = torch.clamp((inter_r - inter_l),<span class="built_in">min</span>=<span class="number">0</span>) * torch.clamp((inter_b - inter_t),<span class="built_in">min</span>=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    c_l = torch.<span class="built_in">min</span>(center_x1 - w1 / <span class="number">2</span>,center_x2 - w2 / <span class="number">2</span>)</span><br><span class="line">    c_r = torch.<span class="built_in">max</span>(center_x1 + w1 / <span class="number">2</span>,center_x2 + w2 / <span class="number">2</span>)</span><br><span class="line">    c_t = torch.<span class="built_in">min</span>(center_y1 - h1 / <span class="number">2</span>,center_y2 - h2 / <span class="number">2</span>)</span><br><span class="line">    c_b = torch.<span class="built_in">max</span>(center_y1 + h1 / <span class="number">2</span>,center_y2 + h2 / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    inter_diag = (center_x2 - center_x1)**<span class="number">2</span> + (center_y2 - center_y1)**<span class="number">2</span></span><br><span class="line">    c_diag = torch.clamp((c_r - c_l),<span class="built_in">min</span>=<span class="number">0</span>)**<span class="number">2</span> + torch.clamp((c_b - c_t),<span class="built_in">min</span>=<span class="number">0</span>)**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    union = area1+area2-inter_area</span><br><span class="line">    u = (inter_diag) / c_diag</span><br><span class="line">    iou = inter_area / union</span><br><span class="line">    dious = iou - u</span><br><span class="line">    dious = torch.clamp(dious,<span class="built_in">min</span>=-<span class="number">1.0</span>,<span class="built_in">max</span> = <span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">if</span> exchange:</span><br><span class="line">        dious = dious.T</span><br><span class="line">    <span class="keyword">return</span> torch.<span class="built_in">sum</span>(<span class="number">1</span>-dious)</span><br></pre></td></tr></table></figure><p>但是DIOU_Loss也依然存在这问题，它没有把预测框的长宽比考虑进去，这就意味着，当预测框中心不变，长宽不同时，DIOU的值是相同的。</p><p><img src="/2021/02/02/cv/loss_in_yolo/diou_short.jpg" alt="diou_short"></p><h2 id="CIOU-Loss"><a href="#CIOU-Loss" class="headerlink" title="CIOU_Loss"></a>CIOU_Loss</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>鉴于DIOU_Loss的问题，由此CIOU_Loss诞生了，在DIOU_Loss的基础上又加上了一个因子v，</p><p><img src="/2021/02/02/cv/loss_in_yolo/ciou.svg" alt="ciou"></p><p>v用来度量长宽比的相似性，定义</p><p><img src="/2021/02/02/cv/loss_in_yolo/ciou_v.svg" alt="ciou_v"></p><p>这样CIOU_Loss就将目标框回归函数应该考虑三个重要几何因素：重叠面积、中心点距离，长宽比全都考虑进去了。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ciou</span>(<span class="params">bboxes1, bboxes2</span>):</span></span><br><span class="line">    bboxes1 = torch.sigmoid(bboxes1)</span><br><span class="line">    bboxes2 = torch.sigmoid(bboxes2)</span><br><span class="line">    rows = bboxes1.shape[<span class="number">0</span>]</span><br><span class="line">    cols = bboxes2.shape[<span class="number">0</span>]</span><br><span class="line">    cious = torch.zeros((rows, cols))</span><br><span class="line">    <span class="keyword">if</span> rows * cols == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> cious</span><br><span class="line">    exchange = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> bboxes1.shape[<span class="number">0</span>] &gt; bboxes2.shape[<span class="number">0</span>]:</span><br><span class="line">        bboxes1, bboxes2 = bboxes2, bboxes1</span><br><span class="line">        cious = torch.zeros((cols, rows))</span><br><span class="line">        exchange = <span class="literal">True</span></span><br><span class="line">    w1 = torch.exp(bboxes1[:, <span class="number">2</span>])</span><br><span class="line">    h1 = torch.exp(bboxes1[:, <span class="number">3</span>])</span><br><span class="line">    w2 = torch.exp(bboxes2[:, <span class="number">2</span>])</span><br><span class="line">    h2 = torch.exp(bboxes2[:, <span class="number">3</span>])</span><br><span class="line">    area1 = w1 * h1</span><br><span class="line">    area2 = w2 * h2</span><br><span class="line">    center_x1 = bboxes1[:, <span class="number">0</span>]</span><br><span class="line">    center_y1 = bboxes1[:, <span class="number">1</span>]</span><br><span class="line">    center_x2 = bboxes2[:, <span class="number">0</span>]</span><br><span class="line">    center_y2 = bboxes2[:, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    inter_l = torch.<span class="built_in">max</span>(center_x1 - w1 / <span class="number">2</span>,center_x2 - w2 / <span class="number">2</span>)</span><br><span class="line">    inter_r = torch.<span class="built_in">min</span>(center_x1 + w1 / <span class="number">2</span>,center_x2 + w2 / <span class="number">2</span>)</span><br><span class="line">    inter_t = torch.<span class="built_in">max</span>(center_y1 - h1 / <span class="number">2</span>,center_y2 - h2 / <span class="number">2</span>)</span><br><span class="line">    inter_b = torch.<span class="built_in">min</span>(center_y1 + h1 / <span class="number">2</span>,center_y2 + h2 / <span class="number">2</span>)</span><br><span class="line">    inter_area = torch.clamp((inter_r - inter_l),<span class="built_in">min</span>=<span class="number">0</span>) * torch.clamp((inter_b - inter_t),<span class="built_in">min</span>=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    c_l = torch.<span class="built_in">min</span>(center_x1 - w1 / <span class="number">2</span>,center_x2 - w2 / <span class="number">2</span>)</span><br><span class="line">    c_r = torch.<span class="built_in">max</span>(center_x1 + w1 / <span class="number">2</span>,center_x2 + w2 / <span class="number">2</span>)</span><br><span class="line">    c_t = torch.<span class="built_in">min</span>(center_y1 - h1 / <span class="number">2</span>,center_y2 - h2 / <span class="number">2</span>)</span><br><span class="line">    c_b = torch.<span class="built_in">max</span>(center_y1 + h1 / <span class="number">2</span>,center_y2 + h2 / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    inter_diag = (center_x2 - center_x1)**<span class="number">2</span> + (center_y2 - center_y1)**<span class="number">2</span></span><br><span class="line">    c_diag = torch.clamp((c_r - c_l),<span class="built_in">min</span>=<span class="number">0</span>)**<span class="number">2</span> + torch.clamp((c_b - c_t),<span class="built_in">min</span>=<span class="number">0</span>)**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    union = area1+area2-inter_area</span><br><span class="line">    u = (inter_diag) / c_diag</span><br><span class="line">    iou = inter_area / union</span><br><span class="line">    v = (<span class="number">4</span> / (math.pi ** <span class="number">2</span>)) * torch.<span class="built_in">pow</span>((torch.atan(w2 / h2) - torch.atan(w1 / h1)), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        S = (iou&gt;<span class="number">0.5</span>).<span class="built_in">float</span>()</span><br><span class="line">        alpha= S*v/(<span class="number">1</span>-iou+v)</span><br><span class="line">    cious = iou - u - alpha * v</span><br><span class="line">    cious = torch.clamp(cious,<span class="built_in">min</span>=-<span class="number">1.0</span>,<span class="built_in">max</span> = <span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">if</span> exchange:</span><br><span class="line">        cious = cious.T</span><br><span class="line">    <span class="keyword">return</span> torch.<span class="built_in">sum</span>(<span class="number">1</span>-cious)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后我们再来综合看下各个iou_loss的不同点：</p><ol><li><p>IOU_Loss：主要考虑检测框和目标框重叠面积。</p></li><li><p>GIOU_Loss：在IOU的基础上，解决边界框不重合时的问题。</p></li><li><p>DIOU_Loss：在IOU和GIOU的基础上，考虑边界框中心点距离的信息。</p></li><li><p>CIOU_Loss：在DIOU的基础上，考虑边界框宽高比的尺度信息。</p></li></ol><p>因此YOLOv4和YOLOV5中均采用了CIOU_Loss的回归方式，使得预测框回归的速度和精度更高一些。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://zhuanlan.zhihu.com/p/94799295">https://zhuanlan.zhihu.com/p/94799295</a></p><p><a href="https://blog.csdn.net/qq_40716944/article/details/114822515?utm_source=app&amp;app_version=4.9.1&amp;utm_source=app">https://blog.csdn.net/qq_40716944/article/details/114822515?utm_source=app&amp;app_version=4.9.1&amp;utm_source=app</a></p><p><a href="https://cloud.tencent.com/developer/article/1664056">https://cloud.tencent.com/developer/article/1664056</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Vision </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Vision </tag>
            
            <tag> Loss Fuction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用激活函数</title>
      <link href="2021/02/01/cv/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
      <url>2021/02/01/cv/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="常用激活函数"><a href="#常用激活函数" class="headerlink" title="常用激活函数"></a>常用激活函数</h1><h2 id="sigmoid"><a href="#sigmoid" class="headerlink" title="sigmoid"></a>sigmoid</h2><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>$$<br>f(x) = \frac{1}{1+e^{-x}}<br>$$</p><h3 id="函数图像"><a href="#函数图像" class="headerlink" title="函数图像"></a>函数图像</h3><p><img src="/2021/02/01/cv/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/sigmoid.jpg" alt="sigmoid"></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>Sigmoid 函数的输出范围是 0 到 1。由于输出值限定在 0 到 1，因此它对每个神经元的输出进行了归一化；</li><li>用于将预测概率作为输出的模型。由于概率的取值范围是 0 到 1，因此 Sigmoid 函数非常合适；</li><li>梯度平滑，避免「跳跃」的输出值；</li><li>函数是可微的。这意味着可以找到任意两个点的 sigmoid 曲线的斜率；</li><li>明确的预测，即非常接近 1 或 0</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>反向传播时倾向于梯度消失；</li><li>函数输出不是以 0 为中心的，这会降低权重更新的效率；</li><li>Sigmoid 函数执行指数运算，计算机运行得较慢</li></ul><h2 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h2><h3 id="公式-1"><a href="#公式-1" class="headerlink" title="公式"></a>公式</h3><p>$$<br>f(x) = \frac{e^x-e^{-x}}{e^x+e^{-x}}<br>$$</p><h3 id="函数图像-1"><a href="#函数图像-1" class="headerlink" title="函数图像"></a>函数图像</h3><p><img src="/2021/02/01/cv/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/tanh.jpg" alt="tanh"></p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>在 tanh 图中，负输入将被强映射为负，而零输入被映射为接近零。</li><li>tanh 的输出间隔为 1，并且整个函数以 0 为中心，比 sigmoid 函数更好</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>仍然存在梯度消失问题</li><li>涉及指数运算，复杂度高一些</li></ul><h2 id="relu"><a href="#relu" class="headerlink" title="relu"></a>relu</h2><h3 id="公式-2"><a href="#公式-2" class="headerlink" title="公式"></a>公式</h3><p>$$<br>\begin{equation}<br>f(x)=\left{<br>\begin{aligned}<br>&amp;max(0, x),&amp;x&gt;=0\<br>&amp;0,&amp;x&lt;0\<br>\end{aligned}<br>\right.<br>\end{equation}<br>$$</p><h3 id="函数图像-2"><a href="#函数图像-2" class="headerlink" title="函数图像"></a>函数图像</h3><p><img src="/2021/02/01/cv/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/relu.jpg" alt="relu"></p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>当输入为正时，不存在梯度饱和问题。</li><li>计算速度快得多。ReLU 函数中只存在线性关系，因此它的计算速度比 sigmoid 和 tanh 更快。</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>当输入为负时，ReLU 完全失效，在正向传播过程中，这不是问题。有些区域很敏感，有些则不敏感。但是在反向传播过程中，如果输入负数，则梯度将完全为零，sigmoid 函数和 tanh 函数也具有相同的问题</p><h2 id="leaky-relu"><a href="#leaky-relu" class="headerlink" title="leaky relu"></a>leaky relu</h2><h3 id="公式-3"><a href="#公式-3" class="headerlink" title="公式"></a>公式</h3><p>$$<br>\begin{equation}<br>f(x)=\left{<br>\begin{aligned}<br>&amp;x&amp;x&gt;=0\<br>&amp;ax,&amp;x&lt;0\<br>\end{aligned}<br>\right.<br>\end{equation}<br>$$</p><h3 id="函数图像-3"><a href="#函数图像-3" class="headerlink" title="函数图像"></a>函数图像</h3><p><img src="/2021/02/01/cv/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/leaky.jpg" alt="leaky"></p><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul><li><p>leak 有助于扩大 ReLU 函数的范围，通常 a 的值为 0.01 左右；</p></li><li><p>Leaky ReLU 的函数范围是（负无穷到正无穷）</p></li></ul><h2 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h2><h2 id="elu"><a href="#elu" class="headerlink" title="elu"></a>elu</h2><h3 id="公式-4"><a href="#公式-4" class="headerlink" title="公式"></a>公式</h3><p>$$<br>\begin{equation}<br>f(x)=\left{<br>\begin{aligned}<br>&amp;x&amp;x&gt;=0\<br>&amp;a(e^x-1),&amp;x&lt;0\<br>\end{aligned}<br>\right.<br>\end{equation}<br>$$</p><h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><ul><li>没有 Dead ReLU 问题，输出的平均值接近 0，以 0 为中心；</li><li>ELU 通过减少偏置偏移的影响，使正常梯度更接近于单位自然梯度，从而使均值向零加速学习；</li><li>ELU 在较小的输入下会饱和至负值，从而减少前向传播的变异和信息。</li></ul><p>一个小问题是它的计算强度更高。与 Leaky ReLU 类似，尽管理论上比 ReLU 要好，但目前在实践中没有充分的证据表明 ELU 总是比 ReLU 好。</p><h2 id="swish"><a href="#swish" class="headerlink" title="swish"></a>swish</h2><h2 id="公式-5"><a href="#公式-5" class="headerlink" title="公式"></a>公式</h2><p>$$<br>f(x) = x * sigmoid(x)<br>$$</p><h3 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h3><ul><li>「无界性」有助于防止慢速训练期间，梯度逐渐接近 0 并导致饱和；（同时，有界性也是有优势的，因为有界激活函数可以具有很强的正则化，并且较大的负输入问题也能解决）；</li><li>导数恒 &gt; 0；</li><li>平滑度在优化和泛化中起了重要作用。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://zhuanlan.zhihu.com/p/163760450">https://zhuanlan.zhihu.com/p/163760450</a></p><p><a href="https://cloud.tencent.com/developer/article/1800954">https://cloud.tencent.com/developer/article/1800954</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Vision </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Vision </tag>
            
            <tag> Activation Fuction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梯度下降</title>
      <link href="2020/06/10/machine_learning/gradient_descent/"/>
      <url>2020/06/10/machine_learning/gradient_descent/</url>
      
        <content type="html"><![CDATA[<h1 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h1><h2 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h2><p>梯度下降是在监督学习中，为了优化模型参数，求出损失函数J(θi)(loss function)取得最小值时，对应的参数θ值的一种迭代算法</p><h2 id="数学公式："><a href="#数学公式：" class="headerlink" title="数学公式："></a>数学公式：</h2><p>​    对于一般的线行回归，假设函数可表示为：<br>$$<br>h_\theta(x) = \theta_0x_0 + \theta_1x_1 + \theta_2x_3 + … + \theta_nx_n<br>$$<br>​    其中n为样本特征数，$\theta_i$(i = 0, 1, 2 … n) 为模型参数，$x_i$(i = 0, 1, 2 … n)  为每个样本的n个特征值，将上式化简后可得：<br>$$<br>h_\theta(x) = \sum_{i=0}^n\theta_ix_i = \theta^Tx<br>$$<br>​    对于上面的假设函数，其损失函数 （平方损失函数）可表示为：<br>$$<br>J(\theta_1,\theta_2…,\theta_n) = \frac{1}{2m} \sum_{j=0}^m(h_\theta(x_0^j,x_1^j…x_n^j)-y^j)^2<br>$$<br>其中m表示为样本个数。</p><p>由此，梯度下降公式可表示为：<br>$$<br>\theta_i=\theta_i-\alpha\frac{\partial}{\partial\theta_i}J(\theta_1,\theta_2…,\theta_n)<br>$$<br>将损失函数带入上式并计算可得：<br>$$<br>\theta_i=\theta_i-\alpha\frac{1}{m} \sum_{j=0}^m(h_\theta(x_0^j,x_1^j…x_n^j)-y^j)x_i^j<br>$$</p><h2 id="公式详解："><a href="#公式详解：" class="headerlink" title="公式详解："></a>公式详解：</h2><p>下面我们以一个最简单的一元线性回归的假设函数举例，其表达式为：$h_\theta(x) = \theta_0x_0+\theta_1x_1$，我们规定$x_0= 1$</p><p>但是我们在推导公式前需要理解以下几个概念和问题，以助于我们更好的理解并推导公式</p><h3 id="什么是假设函数："><a href="#什么是假设函数：" class="headerlink" title="什么是假设函数："></a>什么是假设函数：</h3><p>​        假设函数是对现有训练集的线性拟合，以寻求参数的最佳估计值，这就是我们的学习模型，决定了算法的是否能够精准的预测，比如房价预测，给定了一定数量，一定面积的房屋价格作为训练集，当我们任意给出一套房子的面积时，需要准确得预测出房屋的价格。</p><h3 id="什么是损失函数："><a href="#什么是损失函数：" class="headerlink" title="什么是损失函数："></a>什么是损失函数：</h3><p>​        这是一个用于衡量我们的监督学习模型好坏的标准之一，我们将关于某个样本的预测值（将参数x代入假设函数后的结果）与实际值（样本给予的y关于x的值）的差值称为损失，损失越小，模型越好，那么用于计算这个损失的函数就叫做损失函数</p><p>​        由损失函数可知：当损失函数取得最小值时，那么其对应的参数θ的值，则是模型的最优参数，也就是说，此时以θ为参数的学习模型是最忧的，能达到最精准的预测结果</p><p>​        那么问题就转变成：<strong>如何在损失函数取得最小值时，求出其参数$\theta$的值。</strong>在高等数学中，我们了解到，只需要对函数求导，令它等于零，其解析解为函数取到最值时对应参数的值。但并不是所有函数都可以求出解析解，此时，就衍生出了梯度下降的方法，通过不断迭代改变参数的值进行试探，直至其收敛，就得到了我们需要的参数的解，</p><p><strong>那么问题又来了，梯度下降是如何工作的呢？为什么在迭代时要减去损失函数的偏导呢？为什么不是其他值呢？</strong></p><p>​        我们都知道，偏导数的几何意义是多元函数沿坐标轴的变化率，也就是斜率。这里我们引入一个例子，想象一下我们在一座山上，我们目的是下山，那么自然而然的我们想到在走每一步之前需要确定走的方向。</p><p>山坡图如下：</p><p><img src="/2020/06/10/machine_learning/gradient_descent/v2-8847409b4b6a4cd174b4b75b33b29725_720w.jpg" alt="img"></p><p>​    为了更快的下山，我们最好的选泽肯定是选择一条最陡峭的（意味着花费时间少，作为距离并不考虑实际安全性）的路。”最陡峭” 映射到我们的坐标系中可以表示为曲面沿着任意方向变化率最大的方向，此时引入了一个新的概念叫做”方向导数”，它可以用来表示曲面沿任意方向的斜率，有了它我们就可以求出”最陡峭”的方向，也就是最大斜率。</p><p>​    假设山坡表示为z = f(x,y), y方向的斜率可由对y的偏微分得到 $f_y(x,y)sin\theta$，x方向的斜率也可以对x偏微分得到$f_x(x,y)cos\theta$.</p><p>现在我们有这么一个需求，需要求出u方向的斜率，单位向量$u = cos(\theta)j + sin(\theta)j$, 我们把这个斜率记作$D_uf$,其表达式为：<br>$$<br>D_uf(x,y) = f_x(x,y)cos\theta + f_y(x,y)sin\theta<br>$$</p><p>现在我们的主角”梯度”终于要登场了，梯度就是这个”最陡峭”的方向，它的数学含义表示为一个由方向导数的最大值组成的向量，而它在我们的算法中，梯度就是一个包含了模型参数θ的向量。</p><p>设：$A = (f_x(x,y), f_y(x,y))$，$I = (cos\theta, sin\theta)$，那么我们可以得到$D_Uf(x,y) = A·I = |A| *|I|*cos\theta$，我们令梯度为$J(x,y)$，那么$J(x,y) = maxD_Uf(x,y) =|A| *|I|*cos0 = A = (f_x(x,y), f_y(x,y))$，其中$\theta$为0度</p><p>在梯度下降算法中，我们不断的寻找合适的方向下山（寻找合适的参数）以至于我们能到达山底（梯度下降的距离小于d（趋近于零））</p><p>现在我们可以回答上面的几个问题了:</p><p>梯度下降就是在通过迭代的方式寻找一个合适的参数$\theta$使得损失函数值无限趋近于零（收敛），也就是损失函数取得最小值，而减去损失函数的偏导的意义就在于，为了加快迭代速度（例子中的下山速度），能够更快的得到我们需要的参数\theta</p><p>在算法执行过程中，对于损失函数值无限趋近于零，我们也可以理解成梯度中的每一个数的绝对值都不大于一个数（这个数是人为设定的，一般是1e^-5，这将决定你的算法什么时候终止</p><p>现在，我们可以简单写出一元梯度下降的迭代公式：</p><p>$$<br>\theta_0=\theta_0-\alpha(h_\theta(x_0)-y)x_0<br>$$</p><p>$$<br>\theta_1=\theta_1-\alpha(h_\theta(x_1)-y)x_1<br>$$</p><p>那么现在，我们来分析一下多元梯度下降的迭代公式，已知多元线性回归的假设函数为：<br>$$<br>h_\theta(x) = \sum_{i=0}^n\theta_ix_i = \theta^Tx<br>$$</p><p>对于梯度下降的方法，我们可以得到：<br>$$<br>\theta_0=\theta_0-\alpha(h_\theta(x_0^{(j)})-y^{(j)})x_0^{(j)}<br>$$</p><p>$$<br>\theta_1=\theta_1-\alpha(h_\theta(x_1^{(j)})-y^{(j)})x_1^{(j)}<br>$$</p><p>$$<br>\cdots<br>$$</p><p>$$<br>\theta_n=\theta_n-\alpha(h_\theta(x_n^{(j)})-y^{(j)})x_n^{(j)}<br>$$</p><p>其中上标j表示样本索引，下标表示特征索引，n表示样本总数</p><p>除此之外，还有一种比较直接的方法求参数$\theta$ ，叫做正规方程，通俗点说就是导数值等于零<br>$$<br>\frac{\partial}{\partial\theta_i}J(\theta)=0<br>$$<br>其中<br>$$<br>\theta=\left[\begin{matrix} \theta_0\\theta_1\\theta_2\\cdots\\theta_n \end{matrix}\right]<br>$$<br>现在我们开始求解正规方程：</p><p>​    将$J(\theta)$代入可得：<br>$$<br>\frac{\partial}{\partial\theta_i}\frac{1}{2m} \sum_{j=0}^m(h_\theta(x_0^{(j)},x_1^{(j)}…x_n^{(j)})-y^{(j)})^2 = 0<br>$$<br>​    计算偏导可得：<br>$$<br>\frac{1}{m} \sum_{j=0}^m(h_\theta(x_0^{(j)},x_1^{(j)}…x_n^{(j)})-y^{(j)})x_i^{(j)} = 0<br>$$<br>​    为了简化公式，我们可以将x，y，也就是样本特征值和样本值用矩阵形式来表示，其中上标表示样本，下标表示特征：<br>$$<br>x =\left[\begin{matrix} x_0^1 &amp; x_1^1 &amp;x_2^1 &amp; \cdots&amp;x_n^1 \ x_0^2 &amp; x_1^2 &amp;x_2^2 &amp; \cdots&amp;x_n^2 \ &amp;&amp;\cdots \ x_0^n &amp; x_1^n &amp;x_2^n &amp; \cdots&amp;x_n^n \end{matrix}\right]<br>$$</p><p>$$<br>y=\left[\begin{matrix} y^1 \ y^2 \ \cdots \ y^n \end{matrix}\right]<br>$$</p><p>​    现在我们对上式进行简单的化简，并把式中的$J(\theta)$替换掉得：<br>$$<br>\sum_{j=0}^m(\theta x^T-y^{(j)})x_i^{(j)} = 0<br>$$</p><p>$$<br>\sum_{j=0}^m\theta x^T x_i^{(j)} = \sum_{j=0}^mx_i^{(j)}y^{(j)}<br>$$</p><p>​        由上式可知，其中$\sum_{j=0}^mx^T x_i^{(j)}$实质上就是样本矩阵和他自身的转置相乘，可以转化成$x^Tx$，而右边经过计算可得等于$x^Ty$，是一个n x 1的矩阵，又因为$\theta$是个n维向量，也就是一个n x 1的矩阵，为了使等式成立，因此$\theta$需要左乘$x^Tx$，因此等式可化简为：<br>$$<br>x^Tx\theta=x^Ty<br>$$<br>根据逆矩阵的性质可得：<br>$$<br>\theta = (x^Tx)^{-1}x^Ty<br>$$</p><p>所以由正规方程（normal equation)可得：         $\theta = (x^Tx)^{-1}x^Ty$  </p><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><ol><li><p>梯度和方向导数的意义：<a href="https://www.zhihu.com/question/36301367">https://www.zhihu.com/question/36301367</a></p></li><li><p>梯度下降算法执行过程：<a href="https://blog.csdn.net/weixin_34266504/article/details/94540839">https://blog.csdn.net/weixin_34266504/article/details/94540839</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用操作合集</title>
      <link href="2020/05/08/tool_operation/git/"/>
      <url>2020/05/08/tool_operation/git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git常用操作"><a href="#Git常用操作" class="headerlink" title="Git常用操作"></a>Git常用操作</h1><h2 id="查看当前分支："><a href="#查看当前分支：" class="headerlink" title="查看当前分支："></a>查看当前分支：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><h2 id="查看远程分支："><a href="#查看远程分支：" class="headerlink" title="查看远程分支："></a>查看远程分支：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><h2 id="更新本地分支："><a href="#更新本地分支：" class="headerlink" title="更新本地分支："></a>更新本地分支：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote update origin --prune</span><br><span class="line">git fetch origin --prune    git branch -a</span><br></pre></td></tr></table></figure><h2 id="切换本地分支（若分支在本地未与orgin同步）："><a href="#切换本地分支（若分支在本地未与orgin同步）：" class="headerlink" title="切换本地分支（若分支在本地未与orgin同步）："></a>切换本地分支（若分支在本地未与orgin同步）：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b [branch name]</span><br></pre></td></tr></table></figure><h2 id="删除远程分支："><a href="#删除远程分支：" class="headerlink" title="删除远程分支："></a>删除远程分支：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete [branch name]</span><br></pre></td></tr></table></figure><h2 id="删除本地分支（dev分支）："><a href="#删除本地分支（dev分支）：" class="headerlink" title="删除本地分支（dev分支）："></a>删除本地分支（dev分支）：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D dev</span><br></pre></td></tr></table></figure><h2 id="拉取代码（拉取指定分支）："><a href="#拉取代码（拉取指定分支）：" class="headerlink" title="拉取代码（拉取指定分支）："></a>拉取代码（拉取指定分支）：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><h2 id="拉取代码（与当前分支合并）"><a href="#拉取代码（与当前分支合并）" class="headerlink" title="拉取代码（与当前分支合并）:"></a>拉取代码（与当前分支合并）:</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><h2 id="手动合并（打开merge工具）-："><a href="#手动合并（打开merge工具）-：" class="headerlink" title="手动合并（打开merge工具）  ："></a>手动合并（打开merge工具）  ：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge tool </span><br><span class="line"><span class="meta">#</span><span class="bash"> 打开beyondcompare后左边是当前分支代码，中间是修改前的代码，右边是被合并分支的代码，点击左边箭头进行选择并合并</span></span><br></pre></td></tr></table></figure><p><img src="/2020/05/08/tool_operation/git/clipboard.png" alt="img"></p><h2 id="删除远端文件或文件夹（保留本地文件）"><a href="#删除远端文件或文件夹（保留本地文件）" class="headerlink" title="删除远端文件或文件夹（保留本地文件）:"></a>删除远端文件或文件夹（保留本地文件）:</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm --cache filename</span><br><span class="line">git rm -r --cache dirname</span><br></pre></td></tr></table></figure><h2 id="创建和删除标签："><a href="#创建和删除标签：" class="headerlink" title="创建和删除标签："></a>创建和删除标签：</h2><h3 id="创建："><a href="#创建：" class="headerlink" title="创建："></a>创建：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;标签名&gt;</span><br><span class="line"></span><br><span class="line">git push origin &lt;标签名&gt;</span><br></pre></td></tr></table></figure><h3 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -d &lt;标签名&gt;</span><br><span class="line">git push origin :refs/tags/标签名</span><br></pre></td></tr></table></figure><h2 id="将tag检出的办法："><a href="#将tag检出的办法：" class="headerlink" title="将tag检出的办法："></a>将tag检出的办法：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;new branch&gt; &lt;tag name&gt;</span><br></pre></td></tr></table></figure><h2 id="迁移仓库（从github到gitee"><a href="#迁移仓库（从github到gitee" class="headerlink" title="迁移仓库（从github到gitee)"></a>迁移仓库（从github到gitee)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote remove origin</span><br><span class="line">git remote add origin https://gitee/com/Ztt./homework.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具操作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具操作 </tag>
            
            <tag> 版本管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python项目打包</title>
      <link href="2020/04/20/tool_operation/python_pack/"/>
      <url>2020/04/20/tool_operation/python_pack/</url>
      
        <content type="html"><![CDATA[<h1 id="python项目打包，使用pip安装"><a href="#python项目打包，使用pip安装" class="headerlink" title="python项目打包，使用pip安装"></a>python项目打包，使用pip安装</h1><h2 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h2><p>库发布前先确认你的库是以下这个结构的.<br>project 是最外层的库名<br>package1 是里面的包名<br>module.py 是具体的模块.<br><code>setup.py</code> 和<code>__init__.py</code> 是必须包含的,下面会讲解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">project</span><br><span class="line">    ┝━ setup.py</span><br><span class="line">    ┝━ package1</span><br><span class="line">    │   ┝ __init__.py</span><br><span class="line">    │   ┝ module1.py</span><br><span class="line">    │   └ module2.py</span><br><span class="line">    └─ package2</span><br><span class="line">        ┝ __init__.py</span><br><span class="line">        ┝ module3.py</span><br><span class="line">        └ module4.py</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面以model.py作为例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="comment"># module.py 常用模块</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    print(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    hello()</span><br></pre></td></tr></table></figure><p><strong>setup.py</strong>是必须的，且应该放在项目根目录中，里面的name，version，author，author_email等都是可以自定义的，name决定了你打包完后安装的名字，install_requires在安装时python会自动帮你检查是否有相应的依赖库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> setuptools</span><br><span class="line"></span><br><span class="line">setuptools.setup(</span><br><span class="line">    name=<span class="string">&#x27;agentio&#x27;</span>, <span class="comment"># Replace with your own username</span></span><br><span class="line">    version=<span class="string">&quot;1.1.4&quot;</span>,</span><br><span class="line">    author=<span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">    author_email=<span class="string">&quot;xxxx@xx.com&quot;</span>,</span><br><span class="line">    description=<span class="string">&quot;it is a demo&quot;</span>,</span><br><span class="line">    license=<span class="string">&#x27;MIT&#x27;</span>,</span><br><span class="line">    url=<span class="string">&quot;http://xxx.demo.com&quot;</span>,</span><br><span class="line">    packages=setuptools.find_packages(),</span><br><span class="line">    install_requires=[<span class="string">&#x27;pika&#x27;</span>],</span><br><span class="line">    classifiers=[</span><br><span class="line">        <span class="string">&quot;Programming Language == Python == 3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;License == OSI Approved == MIT License&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Operating System == OS Independent&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="构建库"><a href="#构建库" class="headerlink" title="构建库"></a>构建库</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py build</span><br></pre></td></tr></table></figure><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py sdist</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p>接着就可以正常使用啦！</p>]]></content>
      
      
      <categories>
          
          <category> 工具操作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具操作 </tag>
            
            <tag> python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ的安装与使用</title>
      <link href="2019/12/10/tool_operation/rabbitMQ/"/>
      <url>2019/12/10/tool_operation/rabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ的安装与使用"><a href="#RabbitMQ的安装与使用" class="headerlink" title="RabbitMQ的安装与使用"></a>RabbitMQ的安装与使用</h1><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h3 id="更新软件源"><a href="#更新软件源" class="headerlink" title="更新软件源"></a>更新软件源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h3 id="安装Erlang"><a href="#安装Erlang" class="headerlink" title="安装Erlang"></a>安装Erlang</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install erlang-nox     *# 安装Erlang*</span><br><span class="line">erl</span><br></pre></td></tr></table></figure><h3 id="添加公钥"><a href="#添加公钥" class="headerlink" title="添加公钥"></a>添加公钥</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O- https://www.rabbitmq.com/rabbitmq-release-signing-key.asc | sudo apt-key add -</span><br></pre></td></tr></table></figure><h3 id="安装RabbitMQ-server"><a href="#安装RabbitMQ-server" class="headerlink" title="安装RabbitMQ server"></a>安装RabbitMQ server</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install rabbitmq-server</span><br></pre></td></tr></table></figure><h2 id="安装完成后检查RabbitMQ状态"><a href="#安装完成后检查RabbitMQ状态" class="headerlink" title="安装完成后检查RabbitMQ状态"></a>安装完成后检查RabbitMQ状态</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep rabbit</span><br></pre></td></tr></table></figure><h2 id="开启，重启，关闭RabbitMQ"><a href="#开启，重启，关闭RabbitMQ" class="headerlink" title="开启，重启，关闭RabbitMQ"></a>开启，重启，关闭RabbitMQ</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service rabbitmq-server start# 开启</span><br><span class="line">service rabbitmq-server restart# 重启</span><br><span class="line">service rabbitmq-server stop# 关闭</span><br></pre></td></tr></table></figure><h2 id="启用-web端可视化操作界面"><a href="#启用-web端可视化操作界面" class="headerlink" title="启用 web端可视化操作界面"></a>启用 web端可视化操作界面</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management# 启用插件</span><br></pre></td></tr></table></figure><h2 id="添加管理用户"><a href="#添加管理用户" class="headerlink" title="添加管理用户"></a>添加管理用户</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rabbitmqctl add_user admin 123456   # 增加普通用户 admin是我设定的用户名，123456是我设定的密码</span><br></pre></td></tr></table></figure><h2 id="显示所有用户"><a href="#显示所有用户" class="headerlink" title="显示所有用户"></a>显示所有用户</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rabbitmqctl list_users</span><br></pre></td></tr></table></figure><h2 id="为用户分配管理员角色"><a href="#为用户分配管理员角色" class="headerlink" title="为用户分配管理员角色"></a>为用户分配管理员角色</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rabbitmqctl set_user_tags admin administrator    # 给admin这个用户分配超级管理员角色 </span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">sudo rabbitmqctl start_app# 启动用用</span><br><span class="line">sudo rabbitmqctl stop_app# 关闭应用</span><br><span class="line">sudo rabbitmqctl status# 节点状态</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加用户 例子：sudo rabbitmqctl add_user admin 123456  添加一个名字为admin的用户,密码为123456</span></span><br><span class="line">sudo rabbitmqctl add_user username password </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除用户 例子：sudo rabbitmqctl delete_user admin 删除名字为admin的用户</span></span><br><span class="line">sudo rabbitmqctl delete_user username  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改用户密码 例子：sudo rabbitmqctl change_passowrd admin 456789 将admin用户的密码修改为456789</span></span><br><span class="line">sudo rabbitmqctl change_passowrd username password </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设为用户权限 例子sudo rabbitmqctl set_permissions -p vhostpath admin <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span> 设置admin用户具有最大权限</span></span><br><span class="line">sudo rabbitmqctl set_permissions -p vhostpath username &quot;.*&quot; &quot;.*&quot; &quot;.*&quot; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清除用户权限 例子：sudo rabbitmqctl clear_permissions -p vhostpath admin 清除admin这个用户的所有权限</span></span><br><span class="line">sudo rabbitmqctl clear_permissions -p vhostpath username </span><br><span class="line"> </span><br><span class="line">sudo rabbitmqctl list_users  # 查看所有的用户</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建虚拟主机，注：vhostpath就是虚拟主机的的名称路径；例子：sudo rabbitmqctl add_vhost /test001  创建名字test001的虚拟主机，虚拟主机的路径为/test001  在Rabbitmq中默认的虚拟主机名称路径为/</span></span><br><span class="line">sudo rabbitmqctl add_vhost vhostpath</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  删除虚拟主机 例子sudo rabbitmqctl delete_vhost /test001 删除名称路径为/<span class="built_in">test</span>的虚拟主机</span></span><br><span class="line">sudo rabbitmqctl delete_vhost vhostpath </span><br><span class="line"></span><br><span class="line">sudo rabbitmqctl list_vhosts  # 查看所有的虚拟主机</span><br><span class="line"></span><br><span class="line">sudo rabbitmqctl list_permissions -p vhostpath  # 查看虚拟主机上所有的权限 </span><br><span class="line"></span><br><span class="line">sudo rabbitmqctl list_permissions -p /  # 查看徐您主机名称路径为 /的所有权限</span><br><span class="line"></span><br><span class="line">sudo rabbitmqctl list_permissions -p /test001   # 查看徐您主机名称路径为 /test001的所有权限</span><br><span class="line"> </span><br><span class="line">sudo rabbitmqctl -p vhostpath purge_queue queuename   # 清除队列里的消息 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清除虚拟主机中名称路径为 / 中名称为queuen001队列里中的所有消息</span></span><br><span class="line">sudo rabbitmqctl -p / purge_queue queuen001  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清除虚拟主机中名称路径为 /vhost001 中Queue队列名称为queuen001中的所有消息</span></span><br><span class="line">sudo rabbitmqctl -p /vhost001 purge_queue queuen001  </span><br><span class="line"> </span><br><span class="line">sudo rabbitmqctl list_queues   # 查看所有队列信息</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 移除rabbitmq所有的数据：注意需要在rabbitmqctl stop_app之后才能使用 即：在关闭rabbitmq应用后才能操作</span></span><br><span class="line">sudo rabbitmqctl reset </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 组成集群命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解释：以后我们要组成Rabbitmq集群环境的构建,我们想几个节点组成一个集群，就可以用这个命令</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> [--ram]的意思是 当你加入节点的时候，可以指定这个节点存储的模式是ram ,ram就是一个内存级别的存储（即：我们的数据都落在内存上）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果是[--disc]表示磁盘存储模式（即：我们的数据都落在磁盘上） 默认就是磁盘存储模式</span></span><br><span class="line">sudo rabbitmqctl join_cluster &lt;clusternode&gt; [--ram] </span><br><span class="line"> </span><br><span class="line">sudo rabbitmqctl cluster_status  #查看集群状态</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改集群节点的存储模式 （比如我们在刚刚加入集群节点的时候，如果我忘记了这个节点的存储模式，我们就可以通过这个命令来修改）</span></span><br><span class="line">sudo rabbitmqctl change_cluster_node_type disc| ram </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 忘记节点或者叫 摘除节点 （很有意义的）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如：以后我们做rabbitmq集群的时候，集群在运行一段时间后发现有些节点可能启动不起来了（有可能宕机了），我们就可以通过这个命令将<span class="comment"># 那些启动不起来的节点给&quot;忘记掉&quot; 或者说给&quot;摘除掉&quot; 这就是最简单的故障转移</span></span></span><br><span class="line">sudo rabbitmqctl forget_cluster_node [--offline] </span><br><span class="line"> </span><br><span class="line">sudo rabbitmqctl rename_cluster_node oldnodeName newnodeName  # 修改节点名称</span><br></pre></td></tr></table></figure><h2 id="使用python操作RabbitMQ"><a href="#使用python操作RabbitMQ" class="headerlink" title="使用python操作RabbitMQ"></a>使用python操作RabbitMQ</h2><h3 id="使用direct模式交换器"><a href="#使用direct模式交换器" class="headerlink" title="使用direct模式交换器"></a>使用direct模式交换器</h3><h4 id="定义生产者"><a href="#定义生产者" class="headerlink" title="定义生产者"></a>定义生产者</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(</span><br><span class="line">    pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>)</span><br><span class="line">)</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;d_ex&#x27;</span>, exchange_type=<span class="string">&#x27;direct&#x27;</span>, durable=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    message = <span class="string">f&#x27;time <span class="subst">&#123;i&#125;</span>&#x27;</span></span><br><span class="line">    channel.basic_publish(exchange=<span class="string">&#x27;d_ex&#x27;</span>,</span><br><span class="line">                          routing_key=<span class="string">&#x27;directProducer&#x27;</span>,</span><br><span class="line">                          body=message)</span><br><span class="line">    channel.basic_publish(exchange=<span class="string">&#x27;d_ex&#x27;</span>,</span><br><span class="line">                              routing_key=<span class="string">&#x27;directProducer&#x27;</span>,</span><br><span class="line">                              body=message)</span><br><span class="line">    print(message)</span><br></pre></td></tr></table></figure><h4 id="定义消费者"><a href="#定义消费者" class="headerlink" title="定义消费者"></a>定义消费者</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(</span><br><span class="line">    pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>)</span><br><span class="line">)</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;d_ex&#x27;</span>,exchange_type=<span class="string">&#x27;direct&#x27;</span>,durable=<span class="literal">True</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">&#x27;consumerQueue&#x27;</span>,durable=<span class="literal">True</span>)</span><br><span class="line">channel.queue_bind(exchange=<span class="string">&#x27;d_ex&#x27;</span>, queue=<span class="string">&#x27;consumerQueue&#x27;</span>, routing_key=<span class="string">&#x27;directProducer&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">ch, method, properties,body</span>):</span></span><br><span class="line">    channel.basic_ack(delivery_tag=method.delivery_tag)</span><br><span class="line">    print(body.decode())</span><br><span class="line">channel.basic_consume(queue=<span class="string">&#x27;consumerQueue&#x27;</span>, on_message_callback=callback)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><h3 id="使用fanout模式交换器"><a href="#使用fanout模式交换器" class="headerlink" title="使用fanout模式交换器"></a>使用fanout模式交换器</h3><h4 id="定义生产者-1"><a href="#定义生产者-1" class="headerlink" title="定义生产者"></a>定义生产者</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(</span><br><span class="line">    pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;logs&#x27;</span>, exchange_type=<span class="string">&#x27;fanout&#x27;</span>)</span><br><span class="line"></span><br><span class="line">message = <span class="string">&#x27; &#x27;</span>.join(sys.argv[<span class="number">1</span>:]) <span class="keyword">or</span> <span class="string">&quot;info: Hello World!&quot;</span></span><br><span class="line"></span><br><span class="line">channel.basic_publish(exchange=<span class="string">&#x27;logs&#x27;</span>, routing_key=<span class="string">&#x27;&#x27;</span>, body=message)</span><br><span class="line">print(<span class="string">&quot;send successfully&quot;</span>)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure><h4 id="定义消费者-1"><a href="#定义消费者-1" class="headerlink" title="定义消费者"></a>定义消费者</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(</span><br><span class="line">    pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>)</span><br><span class="line">)</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;logs&#x27;</span>, exchange_type=<span class="string">&#x27;fanout&#x27;</span>,durable=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=<span class="string">&#x27;fanout_queue&#x27;</span>)</span><br><span class="line"></span><br><span class="line">channel.queue_bind(exchange=<span class="string">&#x27;logs&#x27;</span>,queue=<span class="string">&#x27;fanout_queue&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">ch, method, properties, body</span>):</span></span><br><span class="line">    msg = json.loads(body)</span><br><span class="line">    print(msg)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(queue=<span class="string">&#x27;fanout_queue&#x27;</span>, on_message_callback=callback, auto_ack=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具操作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
